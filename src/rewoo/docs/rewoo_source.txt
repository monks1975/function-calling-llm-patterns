<documents>
<document index="1">
<source>src/ReWOO/ai.ts</source>
<document_content>
// ~/src/ReWOO/ai.ts
// class for AI generation tasks

import OpenAI from 'openai';

import type { AiRetryNotification, AiCallbacks } from './types';

import type {
  ChatCompletionMessageParam,
  ChatCompletionCreateParamsBase,
} from 'openai/resources/chat/completions';

export interface AiConfig {
  base_url?: string;
  api_key: string;
  model: string;
  max_tokens?: number | null;
  temperature?: number;
  timeout_ms?: number;
  max_retries?: number;
}

export class AiError extends Error {
  constructor(
    message: string,
    public readonly attempt?: number,
    public readonly status?: number,
    public readonly headers?: Record<string, string>,
    public readonly errorDetails?: Record<string, any>
  ) {
    super(message);
    this.name = 'AiError';
  }
}

// New error class for content moderation issues
export class ContentModerationError extends AiError {
  constructor(
    message: string,
    attempt?: number,
    status?: number,
    headers?: Record<string, string>,
    errorDetails?: Record<string, any>
  ) {
    super(message, attempt, status, headers, errorDetails);
    this.name = 'ContentModerationError';
  }
}

export class AiGenerate {
  protected readonly openai: OpenAI;
  protected readonly config: Required<AiConfig>;

  protected abort_controller: AbortController | null = null;
  protected messages: ChatCompletionMessageParam[] = [];

  constructor(config: AiConfig) {
    this.openai = new OpenAI({
      baseURL: config.base_url,
      apiKey: config.api_key,
    });

    this.config = {
      model: config.model,
      max_tokens: config.max_tokens ?? 8192,
      temperature: config.temperature ?? 0.5,
      timeout_ms: config.timeout_ms ?? 10000,
      max_retries: config.max_retries ?? 3,
      base_url: config.base_url ?? 'https://api.openai.com/v1',
      api_key: config.api_key,
    };
  }

  public async get_completion(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    let attempt = 0;
    let last_error: AiError | Error | null = null;

    while (attempt < this.config.max_retries) {
      try {
        return await this.execute_with_timeout(
          messages,
          response_format,
          callbacks
        );
      } catch (error) {
        // Extract OpenAI API error details if available
        if (error instanceof OpenAI.APIError) {
          const status = error.status;
          const headers = error.headers as Record<string, string>;
          const errorDetails = {
            type: error.type,
            code: error.code,
            param: error.param,
            message: error.message,
          };

          // Check for content moderation errors
          if (
            error.code === 'content_filter' ||
            error.message.includes('content management policy') ||
            error.message.includes('violates OpenAI') ||
            error.message.includes('content policy') ||
            error.message.includes('flagged') ||
            error.message.includes('moderation')
          ) {
            // Don't retry content moderation errors
            throw new ContentModerationError(
              error.message,
              attempt + 1,
              status,
              headers,
              errorDetails
            );
          }

          last_error = new AiError(
            error.message,
            attempt + 1,
            status,
            headers,
            errorDetails
          );
        } else {
          last_error =
            error instanceof Error ? error : new Error(String(error));
        }

        if (last_error.name === 'AbortError') {
          throw last_error;
        }

        if (!(await this.handle_retry(++attempt, last_error, callbacks))) {
          break;
        }
      }
    }

    if (last_error instanceof AiError) {
      throw last_error;
    } else {
      throw new AiError(
        `Failed after ${this.config.max_retries} attempts. Last error: ${last_error?.message}`,
        attempt
      );
    }
  }

  protected async execute_with_timeout(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    this.abort_controller = new AbortController();

    const timeout_promise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        const error = new AiError(
          `Request timed out after ${this.config.timeout_ms}ms`
        );
        reject(error);
      }, this.config.timeout_ms);
    });

    try {
      return await Promise.race([
        this.execute(messages, response_format, callbacks),
        timeout_promise,
      ]);
    } finally {
      this.abort_controller = null;
    }
  }

  protected async execute(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    const completion = await this.openai.chat.completions.create(
      {
        model: this.config.model,
        messages,
        max_tokens: this.config.max_tokens,
        temperature: this.config.temperature,
        response_format: response_format,
      },
      {
        signal: this.abort_controller?.signal,
      }
    );

    // Notify via callback instead of event
    callbacks?.onCompletion?.(completion);

    return completion.choices[0]?.message?.content ?? '';
  }

  protected async handle_retry(
    attempt: number,
    error: Error,
    callbacks?: AiCallbacks
  ): Promise<boolean> {
    if (attempt >= this.config.max_retries) {
      return false;
    }

    const backoff_ms = Math.min(
      1000 * Math.pow(2, attempt) + Math.random() * 1000,
      10000
    );

    const notification: AiRetryNotification = {
      type: 'retry',
      attempt,
      backoff_ms,
      error: error.message,
    };

    // Add additional error details if available
    if (error instanceof AiError) {
      notification.status = error.status;
      notification.headers = error.headers;
      notification.errorDetails = error.errorDetails;
    }

    // Notify via callback instead of event
    callbacks?.onRetry?.(notification);

    await new Promise((resolve) => setTimeout(resolve, backoff_ms));
    return true;
  }

  public async get_embedding(text: string): Promise<number[]> {
    try {
      const response = await this.openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: text,
      });
      return response.data[0].embedding;
    } catch (error) {
      console.error('Error getting embedding:', error);
      throw error;
    }
  }

  public abort(): void {
    this.abort_controller?.abort();
  }

  public add_message(message: ChatCompletionMessageParam): void {
    this.messages.push(message);
  }

  public get_messages(): ChatCompletionMessageParam[] {
    return [...this.messages];
  }

  public reset_messages(): void {
    // Keep only the first message (system prompt) if it exists
    this.messages = this.messages.length > 0 ? [this.messages[0]] : [];
  }

  public cleanup(): void {
    // Abort any pending requests
    this.abort();

    // Clear message history to help garbage collection
    this.messages = [];
  }
}

</document_content>
</document>
<document index="2">
<source>src/ReWOO/cli.ts</source>
<document_content>
// ~/src/ReWOO/cli.ts

import dotenv from 'dotenv';
import readline from 'readline';
import fs from 'fs';
import path from 'path';

import { format_state_as_markdown } from './helpers';
import { MemoryService } from './services/memory_service';
import { ReWOO } from './rewoo';

import { LlmTool } from './tools/llm.tool';
import { MemoryByKeywordTool } from './tools/memory_by_keyword.tool';
import { RecentMemoryTool } from './tools/recent_memory.tool';
import { SearchTool } from './tools/search.tool';

dotenv.config();

function create_cli() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const ai_config = {
    api_key: process.env.CEREBRAS_API_KEY || '',
    base_url: 'https://api.cerebras.ai/v1',
    model: 'llama-3.3-70b',
    temperature: 0.5,
  };

  const ai_embedding_config = {
    api_key: process.env.OPENAI_API_KEY || '',
    model: 'gpt-4o-mini',
    temperature: 0.7,
  };

  // Initialize tools
  const llm_tool = new LlmTool(ai_config);
  const search_tool = new SearchTool(process.env.TAVILY_API_KEY || '');
  const memory_by_keyword_tool = new MemoryByKeywordTool(ai_embedding_config);
  const recent_memory_tool = new RecentMemoryTool();

  const memory_service = new MemoryService(ai_embedding_config);

  // Create ReWOO instance
  const rewoo = new ReWOO(
    ai_config,
    [llm_tool, search_tool, memory_by_keyword_tool, recent_memory_tool],
    {
      onPlan: (state) => {
        console.log('\nüîç Plan created:');
        // if (state.steps) {
        //   state.steps.forEach((step, index) => {
        //     console.log(`  ${index + 1}. ${step.plan}`);
        //     console.log(`     Tool: ${step.tool}[${step.args}]`);
        //   });
        // }
      },
      onToolExecute: (step, result) => {
        console.log(`\nüîß Executing step: ${step.variable}`);
        console.log(`   Plan: ${step.plan}`);
        console.log(`   Tool: ${step.tool}[${step.args}]`);
      },
      onSolve: async (state) => {
        console.log('\n‚úÖ Solution found');

        // Log session state as markdown
        const log_dir = path.join(__dirname, 'logs');
        const log_file = path.join(log_dir, `${rewoo.session_id}_log.md`);
        const markdown = format_state_as_markdown(state);
        await fs.promises.writeFile(log_file, markdown);
        console.log(`üìù Session logged to: ${log_file}`);
      },
      onError: (error) => console.error('\n‚ùå Error:', error.message),
    }
  );

  console.log('üöÄ ReWOO CLI Started - Enter a task or type "q" to quit');
  console.log(`üìå Session ID: ${rewoo.session_id}`);

  function prompt_user() {
    rl.question('\nüìù Enter your task: ', async (task) => {
      if (task.toLowerCase() === 'q') {
        await memory_service.cleanup();
        rl.close();
        return;
      }

      // Skip empty tasks and re-prompt
      if (!task.trim()) {
        console.log('‚ùå Task cannot be empty. Please try again.');
        prompt_user();
        return;
      }

      try {
        console.log(`\n‚è≥ Processing task: "${task}"`);
        const result = await rewoo.process(task);

        console.log('\nüìä Result:');
        console.log(result.result);

        // Store the solution
        if (result.result) {
          await memory_service.store_solution(
            rewoo.session_id,
            task,
            result.result,
            {
              steps_count: result.steps?.length || 0,
              errors: result.errors?.length || 0,
            }
          );
        }

        prompt_user();
      } catch (error) {
        console.error('‚ùå Error:', error);
        prompt_user();
      }
    });
  }

  prompt_user();

  // Handle process termination
  process.on('SIGINT', async () => {
    console.log('\nExiting...');
    await memory_service.cleanup();
    process.exit(0);
  });
}

if (require.main === module) {
  create_cli();
}

export { create_cli };

</document_content>
</document>
<document index="3">
<source>src/ReWOO/helpers.ts</source>
<document_content>
// ~/src/ReWOO/helpers.ts

import { State } from './types';

function escape_markdown(text: string): string {
  // Escape special markdown characters
  return text.replace(/[_*`[\]()~>#+=|{}.!-]/g, '\\$&');
}

function escape_code_block(text: string): string {
  // Escape backticks and ensure no ``` sequences
  return text.replace(/`/g, '\\`').replace(/```/g, '\\`\\`\\`');
}

export function format_state_as_markdown(state: State): string {
  const md: string[] = [];

  // Header with session info
  md.push(`# ReWOO Session Log\n`);
  md.push(`**Session ID:** \`${escape_code_block(state.session_id)}\`\n`);
  md.push(
    `**Timestamp:** ${new Date(state.timestamp || Date.now()).toISOString()}\n`
  );
  md.push(`**Task:** ${escape_markdown(state.task)}\n`);

  // Plan section
  if (state.plan_string) {
    md.push(`\n## Plan\n\n${escape_markdown(state.plan_string)}\n`);
  }

  // Steps section
  if (state.steps?.length) {
    md.push(`\n## Execution Steps\n`);
    state.steps.forEach((step, index) => {
      md.push(`\n### Step ${index + 1}\n`);
      md.push(`- **Tool:** \`${escape_code_block(step.tool)}\``);
      md.push(`- **Variable:** \`${escape_code_block(step.variable)}\``);
      md.push(`- **Plan:** ${escape_markdown(step.plan)}`);
      if (step.args) {
        md.push(`- **Arguments:** \`${escape_code_block(step.args)}\``);
      }
    });
  }

  // Results section
  if (state.results) {
    md.push(`\n## Results\n`);
    Object.entries(state.results).forEach(([variable, result]) => {
      md.push(`\n### ${escape_markdown(variable)}\n`);
      md.push(`\`\`\`\n${escape_code_block(result)}\n\`\`\`\n`);
    });
  }

  // Final Result section
  if (state.result) {
    md.push(`\n## Final Result\n\n${escape_markdown(state.result)}\n`);
  }

  // Errors section (if any)
  if (state.errors?.length) {
    md.push(`\n## Errors\n`);
    state.errors.forEach((error, index) => {
      md.push(`\n### Error ${index + 1}\n`);
      md.push(`\`\`\`\n${escape_code_block(error)}\n\`\`\`\n`);
    });
  }

  // Token Usage section
  if (state.token_usage?.length) {
    md.push(`\n## Token Usage\n`);
    md.push(`| Source | Tool | Prompt | Completion | Total |`);
    md.push(`|--------|------|---------|------------|--------|`);
    state.token_usage.forEach((usage) => {
      md.push(
        `| ${usage.source} | ${usage.tool_name || '-'} | ${
          usage.prompt_tokens
        } | ${usage.completion_tokens} | ${usage.total_tokens} |`
      );
    });

    // Add totals row
    const totals = state.token_usage.reduce(
      (acc, curr) => ({
        prompt_tokens: acc.prompt_tokens + curr.prompt_tokens,
        completion_tokens: acc.completion_tokens + curr.completion_tokens,
        total_tokens: acc.total_tokens + curr.total_tokens,
      }),
      { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    );

    md.push(
      `| **Total** | - | **${totals.prompt_tokens}** | **${totals.completion_tokens}** | **${totals.total_tokens}** |`
    );
  }

  return md.join('\n');
}

</document_content>
</document>
<document index="4">
<source>src/ReWOO/planner.ts</source>
<document_content>
// ~/src/ReWOO/planner.ts

import Handlebars from 'handlebars';

import { AiGenerate, type AiConfig } from './ai';

import type { State, Tool, ToolCallbacks } from './types';

// Handlebars template for the planner prompt
// prettier-ignore
const planner_template = Handlebars.compile(
`You are an expert planner that breaks tasks into sequential steps.

Today's date: {{today}}

Available tools:
{{#each tools}}
({{name}})[input]: {{description}}
{{/each}}

Create ONE sequential plan to solve the given task. Each step must follow this format exactly:
Plan: <description> #E<number> = <tool>[<args>]

Rules:
1. Create exactly ONE plan - do not revise or provide alternatives
2. Each step must have exactly one #E variable
3. Number steps sequentially starting at #E1
4. Each step must use an available tool
5. Later steps can reference earlier #E variables in their args

Examples:

Task: What are the latest developments in quantum computing?
Plan: Search for current quantum computing news. #E1 = Search[latest quantum computing breakthroughs 2024]
Plan: Analyze and summarize findings. #E2 = LLM[Summarize key developments from (#E1)]

Task: Explain how blockchain works
Plan: Search for technical details. #E1 = Search[blockchain technology explanation]
Plan: Create clear explanation. #E2 = LLM[Create beginner-friendly explanation from (#E1)]

Task: What is the capital of France?
Plan: Search for basic facts. #E1 = Search[capital of France facts]
Plan: Format response clearly. #E2 = LLM[Create concise response about Paris from (#E1)]

Task: What happened in the latest SpaceX launch?
Plan: Search recent news. #E1 = Search[latest SpaceX launch news]
Plan: Summarize key points. #E2 = LLM[Create summary of launch from (#E1)]

Task: Define the word "serendipity"
Plan: Search for definition. #E1 = Search[serendipity definition and examples]
Plan: Create clear explanation. #E2 = LLM[Format definition and examples from (#E1)]

Task: What did we discuss about climate change last week?
Plan: Search recent memory for climate discussions. #E1 = RecentMemory[climate change]
Plan: Analyze and summarize the conversation. #E2 = LLM[Create summary from (#E1)]

Task: What have I asked about artificial intelligence?
Plan: Search memory for AI-related queries. #E1 = MemoryByKeyword[artificial intelligence, AI, machine learning]
Plan: Create comprehensive overview. #E2 = LLM[Synthesize AI discussions from (#E1)]

Task: Find our previous discussions about renewable energy
Plan: Search memory for energy topics. #E1 = MemoryByKeyword[renewable energy, solar, wind power]
Plan: Organize key points. #E2 = LLM[Create structured summary from (#E1)]

Task: What background do we have on space exploration?
Plan: Retrieve space-related memories. #E1 = MemoryByKeyword[space exploration, NASA, astronomy]
Plan: Create contextual summary. #E2 = LLM[Build comprehensive context from (#E1)]

Task: What have we covered about quantum physics?
Plan: Get quantum physics discussions. #E1 = MemoryByKeyword[quantum physics, quantum mechanics]
Plan: Synthesize learning progress. #E2 = LLM[Create learning timeline from (#E1)]

Begin!
Describe your plans with rich details. Each Plan should be followed by only one #E.
Task: {{task}}`
);

export class PlannerAgent {
  private ai: AiGenerate;
  private tools: Tool[];
  private callbacks?: ToolCallbacks;
  private readonly regex_pattern =
    /Plan:\s*(.+)\s*(#E\d+)\s*=\s*(\w+)\s*\[([^\]]+)\]/g;

  constructor(ai_config: AiConfig, tools: Tool[], callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.tools = tools;
    this.callbacks = callbacks;
  }

  async create_plan(task: string): Promise<Partial<State>> {
    try {
      this.callbacks?.onExecuteStart?.('Creating execution plan');

      const system_message = this.create_system_prompt();
      const user_message = this.create_user_prompt(task);

      // Get the plan from the AI
      const result = await this.ai.get_completion(
        [
          { role: 'system', content: system_message },
          { role: 'user', content: user_message },
        ],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'planner');
          },
        }
      );

      // Parse the plan using regex
      const matches = Array.from(result.matchAll(this.regex_pattern));
      let plan_result: Partial<State>;

      if (matches.length === 0) {
        // Fallback to ensure at least one step
        plan_result = {
          plan_string: result,
          steps: [
            {
              plan: 'Get information about the topic',
              variable: '#E1',
              tool: 'LLM',
              args: task,
            },
          ],
        };

        this.callbacks?.onExecuteComplete?.('Created fallback plan');
      } else {
        const steps = matches.map((match) => ({
          plan: match[1].trim(),
          variable: match[2].trim(),
          tool: match[3].trim(),
          args: match[4].trim(),
        }));

        plan_result = {
          plan_string: result,
          steps,
        };

        this.callbacks?.onExecuteComplete?.(
          `Created plan with ${steps.length} steps`
        );
      }

      return plan_result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);

      // Return a minimal fallback plan
      return {
        plan_string: 'Error creating plan, using fallback',
        steps: [
          {
            plan: 'Get information about the topic',
            variable: '#E1',
            tool: 'LLM',
            args: task,
          },
        ],
      };
    }
  }

  private create_system_prompt(): string {
    return `You are an expert planner that breaks tasks into sequential steps.`;
  }

  private create_user_prompt(task: string): string {
    return planner_template({
      tools: this.tools,
      today: new Date().toLocaleDateString('en-GB'),
      task,
    });
  }
}

</document_content>
</document>
<document index="5">
<source>src/ReWOO/rewoo.ts</source>
<document_content>
// ~/src/ReWOO/rewoo.ts
//
// Event System Architecture:
// - Built on Node's EventEmitter for pub/sub event handling
// - Two-layer event system:
//   1. Low-level tool events (tool_start, tool_complete, error)
//   2. High-level process events (plan, solve)
// - Callbacks can be registered for granular control

import { EventEmitter } from 'events';
import { v4 as uuid } from 'uuid';

import { PlannerAgent } from './planner';
import { SolverAgent } from './solver';
import { Worker } from './worker';

import type { AiConfig } from './ai';
import type { EvidenceRecord, State } from './types';
import type { ExecutionEvent, ExecutionContext } from './types';
import type { ReWOOCallbacks, ReWOOEventEmitter, ReWOOEventMap } from './types';
import type { Tool, ToolCallbacks } from './types';

export class ReWOO extends EventEmitter implements ReWOOEventEmitter {
  private planner: PlannerAgent;
  private worker: Worker;
  private solver: SolverAgent;
  private callbacks?: ReWOOCallbacks;
  private state: State = { session_id: uuid(), task: '' };
  private tools: Tool[] = [];

  constructor(ai_config: AiConfig, tools: Tool[], callbacks?: ReWOOCallbacks) {
    super();
    this.callbacks = callbacks;
    this.tools = tools;

    // Increase event listener limit to handle tool-specific events
    this.setMaxListeners(tools.length + 10);

    // 1. Low-level tool events (tool_start, tool_complete, error)
    // 2. High-level process events (plan, solve)

    // Tool callback adapter maps low-level tool events to the event system

    const tool_callbacks: ToolCallbacks = {
      onExecuteStart: (args) => {
        this.emit_execution_event({
          type: 'tool_start',
          context: this.create_execution_context({ args }),
        });
      },
      onExecuteComplete: (result, step) => {
        this.emit_execution_event({
          type: 'tool_complete',
          context: this.create_execution_context({ step }),
          data: result,
        });
      },
      onExecuteError: (error) => {
        this.emit_execution_event({
          type: 'error',
          context: this.create_execution_context(),
          error,
        });
      },
      onCompletion: (completion, source = 'tool', tool_name?: string) => {
        const tokens = completion.usage
          ? {
              prompt: completion.usage.prompt_tokens,
              completion: completion.usage.completion_tokens,
              total: completion.usage.total_tokens,
            }
          : undefined;

        if (tokens) {
          if (!this.state.token_usage) {
            this.state.token_usage = [];
          }
          this.state.token_usage.push({
            source,
            tool_name,
            prompt_tokens: tokens.prompt,
            completion_tokens: tokens.completion,
            total_tokens: tokens.total,
          });
        }

        this.emit_execution_event({
          type: 'completion',
          context: this.create_execution_context(),
          data: {
            completion,
            source,
            tool_name,
            tokens,
          },
        });
      },
    };

    // Each tool gets access to the event emitter for publishing tool-specific events
    tools.forEach((tool) => {
      tool.emitter = this;
    });

    this.planner = new PlannerAgent(ai_config, tools, tool_callbacks);
    this.worker = new Worker(tools, ai_config, tool_callbacks);
    this.solver = new SolverAgent(ai_config, tool_callbacks);
  }

  // Override emit to ensure all events also trigger the generic onEvent callback
  emit<K extends keyof ReWOOEventMap>(
    event: K,
    args: ReWOOEventMap[K]
  ): boolean {
    this.callbacks?.onEvent?.(args);
    return super.emit(event, args);
  }

  // Central event dispatcher that maps execution events to specific callbacks
  // Handles both tool events and process lifecycle events
  private emit_execution_event(event: ExecutionEvent): void {
    // Emit the event
    this.emit('rewoo:event', event);

    // Map events to callbacks
    switch (event.type) {
      case 'plan':
        this.callbacks?.onPlan?.(event.context.state!);
        break;
      case 'tool_complete':
        if (event.context.step) {
          this.callbacks?.onToolExecute?.(
            event.context.step,
            event.data as string
          );
        }
        break;
      case 'solve':
        this.callbacks?.onSolve?.(event.context.state!);
        break;
      case 'error':
        if (event.error) {
          this.callbacks?.onError?.(event.error, event.context.state!);
        }
        break;
    }
  }

  // Creates consistent execution context for all events
  // Ensures events have access to current state and session info
  private create_execution_context(
    partial?: Partial<ExecutionContext>
  ): ExecutionContext {
    return {
      session_id: this.state.session_id,
      task: this.state.task,
      state: this.state,
      ...partial,
    };
  }

  // Comprehensive cleanup of event listeners and references
  // Prevents memory leaks and ensures proper teardown
  async cleanup(): Promise<void> {
    // Remove all event listeners
    this.removeAllListeners();

    // Remove emitter references from tools
    this.tools.forEach((tool) => {
      tool.emitter = undefined;
    });

    // Clear tools array
    this.tools = [];

    // Cleanup components that might have their own cleanup needs
    if ('cleanup' in this.worker && typeof this.worker.cleanup === 'function') {
      await this.worker.cleanup();
    }
    if (
      'cleanup' in this.planner &&
      typeof this.planner.cleanup === 'function'
    ) {
      await this.planner.cleanup();
    }
    if ('cleanup' in this.solver && typeof this.solver.cleanup === 'function') {
      await this.solver.cleanup();
    }

    // Clear callbacks
    this.callbacks = undefined;
  }

  // Add getters
  get session_id(): string {
    return this.state.session_id;
  }

  get current_state(): State {
    return { ...this.state };
  }

  // Getter for evidence records in a session; row-based
  // Maps to evidence table schema
  get evidence_records(): EvidenceRecord[] {
    return Object.entries(this.state.results || {}).map(
      ([variable, content], idx) => ({
        session_id: this.state.session_id,
        evidence_id: `E${idx + 1}`,
        content,
        created_at: this.state.timestamp || Date.now(),
        step_variable: variable,
      })
    );
  }

  async process(task: string): Promise<State> {
    this.state = {
      session_id: this.state.session_id,
      task,
      timestamp: Date.now(),
      errors: [],
    };

    try {
      const plan_result = await this.planner.create_plan(task);
      this.state = { ...this.state, ...plan_result };

      this.emit_execution_event({
        type: 'plan',
        context: this.create_execution_context(),
        data: plan_result,
      });

      if (this.state.steps && this.state.steps.length > 0) {
        this.state.results = {};

        for (const step of this.state.steps) {
          try {
            const result = await this.worker.execute_step(
              step,
              this.state.results
            );
            this.state.results[step.variable] = result;
          } catch (error) {
            const err =
              error instanceof Error ? error : new Error(String(error));
            this.state.results[step.variable] = `Error: ${err.message}`;

            this.emit_execution_event({
              type: 'error',
              context: this.create_execution_context({ step }),
              error: err,
            });
          }
        }
      }

      const solution = await this.solver.solve(this.state);
      this.state.result = solution;

      this.emit_execution_event({
        type: 'solve',
        context: this.create_execution_context(),
        data: solution,
      });

      return this.state;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));

      this.emit_execution_event({
        type: 'error',
        context: this.create_execution_context(),
        error: err,
      });

      if (!this.state.result) {
        try {
          const fallback = await this.solver.solve(this.state);
          this.state.result = fallback;
        } catch (solveError) {
          this.state.result = 'Unable to complete the task due to errors.';
        }
      }

      return this.state;
    }
  }
}

</document_content>
</document>
<document index="6">
<source>src/ReWOO/solver.ts</source>
<document_content>
// ~/src/ReWOO/solver.ts

import Handlebars from 'handlebars';

import { AiGenerate, type AiConfig } from './ai';

import type { State, ToolCallbacks } from './types';

// Template for the system prompt
const solver_template = `You are an expert at solving tasks using provided evidence.
Your role is to analyze the evidence and provide a clear, accurate solution.
If evidence is missing or incomplete, use your best judgment but be transparent about any assumptions.`;

// Template for the user prompt
// prettier-ignore
const user_template = Handlebars.compile(
`Solve the following task. To help you solve the task, we have made step-by-step Plans and retrieved corresponding Evidence for each Plan. Use them with caution since long evidence might contain irrelevant information. You will need to sift through the evidence to find the most relevant information to solve the problem.

{{plan_with_evidence}}

Now solve the task or problem according to the provided Evidence above. If evidence is missing or incomplete, use your best judgment.
Task: {{task}}

First, briefly summarize the key information from each piece of evidence. Then provide your final answer.`
);

export class SolverAgent {
  private ai: AiGenerate;
  private callbacks?: ToolCallbacks;

  constructor(ai_config: AiConfig, callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.callbacks = callbacks;
  }

  async solve(state: State): Promise<string> {
    try {
      this.callbacks?.onExecuteStart?.('Solving task with collected evidence');

      // Format the plan and evidence for better visibility
      let plan_with_evidence = '';

      if (state.steps && state.results) {
        for (const step of state.steps) {
          const result = state.results[step.variable] || '(No result)';
          const result_summary =
            result.length > 300
              ? result.substring(0, 300) + '... (truncated)'
              : result;

          plan_with_evidence += `Step: ${step.plan}\n`;
          plan_with_evidence += `Tool: ${step.tool}[${step.args}]\n`;
          plan_with_evidence += `**Evidence ${step.variable}:**\n${result_summary}\n\n`;
        }
      } else if (state.plan_string) {
        plan_with_evidence = state.plan_string;
      }

      const user_prompt = user_template({
        plan_with_evidence,
        task: state.task,
      });

      const result = await this.ai.get_completion(
        [
          { role: 'system', content: solver_template },
          { role: 'user', content: user_prompt },
        ],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'solver');
          },
        }
      );

      this.callbacks?.onExecuteComplete?.('Generated solution');
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);
      throw err;
    }
  }
}

</document_content>
</document>
<document index="7">
<source>src/ReWOO/todo.md</source>
<document_content>
## ReWOO Todos

- [ ] API key recycling
- [ ] Library tool
- [ ] Token counting (including from tools)
- [ ] Context from previous messages -> transform task

## Notes

</document_content>
</document>
<document index="8">
<source>src/ReWOO/tsconfig.json</source>
<document_content>
// ~/src/ReWOO/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "../../dist/rewoo",
    "declaration": true,
    "typeRoots": ["../../node_modules/@types", "types"]
  },
  "include": ["**/*"],
  "exclude": ["node_modules", "dist"]
}

</document_content>
</document>
<document index="9">
<source>src/ReWOO/types.ts</source>
<document_content>
// ~/src/ReWOO/types.ts
import { z } from 'zod';

import type { ChatCompletion } from 'openai/resources/chat';

// Step definition schema
export const StepSchema = z.object({
  plan: z.string(),
  variable: z.string().regex(/^#E\d+$/),
  tool: z.string(),
  args: z.string(),
});

export type Step = z.infer<typeof StepSchema>;

// State schema for tracking execution
export const StateSchema = z.object({
  session_id: z.string(),
  task: z.string(),
  plan_string: z.string().optional(),
  steps: z.array(StepSchema).optional(),
  results: z.record(z.string()).optional(),
  result: z.string().optional(),
  timestamp: z.number().optional(),
  errors: z.array(z.string()).optional(),
  token_usage: z
    .array(
      z.object({
        source: z.string(),
        tool_name: z.string().optional(),
        prompt_tokens: z.number(),
        completion_tokens: z.number(),
        total_tokens: z.number(),
      })
    )
    .optional(),
});

export type State = z.infer<typeof StateSchema>;

export interface ExecutionContext {
  session_id: string;
  task: string;
  step?: Step;
  tool?: string;
  args?: string;
  state?: State;
}

export interface CompletionEvent extends ExecutionEvent {
  type: 'completion';
  data: {
    completion: CompletionWithRequestId;
    source: 'planner' | 'solver' | 'worker' | 'tool';
    tool_name?: string;
    tokens?: {
      prompt: number;
      completion: number;
      total: number;
    };
  };
}

export interface ExecutionEvent {
  type:
    | 'tool_start'
    | 'tool_complete'
    | 'plan'
    | 'solve'
    | 'error'
    | 'completion';
  context: ExecutionContext;
  data?: unknown;
  error?: Error;
}

// Custom event map for type safety
export interface ReWOOEventMap {
  'rewoo:event': ExecutionEvent | CompletionEvent;
}

// Extend Node's EventEmitter with our custom events
export interface ReWOOEventEmitter extends NodeJS.EventEmitter {
  emit<K extends keyof ReWOOEventMap>(
    event: K,
    args: ReWOOEventMap[K]
  ): boolean;
  on<K extends keyof ReWOOEventMap>(
    event: K,
    listener: (args: ReWOOEventMap[K]) => void
  ): this;
}

// Core callbacks for all operations
export interface ReWOOCallbacks {
  onEvent?: (event: ExecutionEvent) => void;
}

// Tool interface for all tools to implement
export interface Tool {
  name: string;
  description: string;
  emitter?: ReWOOEventEmitter;
  execute(args: string): Promise<string>;
  cleanup?(): Promise<void>;
}

// Base completion type used throughout the application
export type CompletionWithRequestId = ChatCompletion & {
  _request_id?: string | null;
};

export interface AiRetryNotification {
  type: 'retry';
  attempt: number;
  backoff_ms: number;
  error: string;
  status?: number;
  headers?: Record<string, string>;
  errorDetails?: Record<string, any>;
}

// Core callbacks for AI operations
export interface AiCallbacks {
  onRetry?: (notification: AiRetryNotification) => void;
  onCompletion?: (
    completion: CompletionWithRequestId,
    source?: 'planner' | 'solver' | 'worker' | 'tool',
    tool_name?: string
  ) => void;
}

// Tool-specific callbacks extend AI callbacks
export interface ToolCallbacks extends AiCallbacks {
  onExecuteStart?: (args: string) => void;
  onExecuteComplete?: (result: string, step?: Step) => void;
  onExecuteError?: (error: Error) => void;
}

// ReWOO-specific callbacks extend AI callbacks
export interface ReWOOCallbacks extends AiCallbacks {
  onPlan?: (state: State) => void;
  onToolExecute?: (step: Step, result: string) => void;
  onSolve?: (state: State) => void;
  onError?: (error: Error, state: State) => void;
}

// EvidenceRecord is a record of evidence for a session
export interface EvidenceRecord {
  session_id: string;
  evidence_id: string; // E1, E2, etc.
  content: string;
  created_at: number;
  step_variable: string;
}

</document_content>
</document>
<document index="10">
<source>src/ReWOO/worker.ts</source>
<document_content>
// ~/src/ReWOO/worker.ts

import { AiGenerate, type AiConfig } from './ai';

import type { Step, Tool, ToolCallbacks } from './types';

export class Worker {
  private tools: Map<string, Tool>;
  private fallback_ai: AiGenerate;
  private tool_callbacks?: ToolCallbacks;

  constructor(
    tools: Tool[],
    ai_config: AiConfig,
    tool_callbacks?: ToolCallbacks
  ) {
    this.tool_callbacks = tool_callbacks;
    this.fallback_ai = new AiGenerate(ai_config);

    // Initialize tools map with callbacks
    this.tools = new Map(tools.map((tool) => [tool.name, tool]));
  }

  async cleanup(): Promise<void> {
    // Clear callbacks
    this.tool_callbacks = undefined;

    // Clear tools map
    this.tools.clear();

    // Cleanup any tools that have cleanup methods
    for (const tool of this.tools.values()) {
      if ('cleanup' in tool && typeof tool.cleanup === 'function') {
        await tool.cleanup();
      }
    }
  }

  async execute_step(
    step: Step,
    results: Record<string, string> = {}
  ): Promise<string> {
    // Process variable substitutions in the args
    let processed_args = step.args;
    for (const [key, value] of Object.entries(results)) {
      processed_args = processed_args.replace(key, value);
    }

    // Get the tool and execute it
    const tool = this.tools.get(step.tool);

    this.tool_callbacks?.onExecuteStart?.(processed_args);

    try {
      let result: string;

      if (!tool) {
        console.warn(`Tool "${step.tool}" not found, using fallback AI`);
        result = await this.execute_fallback(step.tool, processed_args);
      } else {
        // If it's an LLM tool, ensure it has the callbacks
        if (tool.name === 'LLM' && 'callbacks' in tool) {
          tool.callbacks = this.tool_callbacks;
        }
        result = await tool.execute(processed_args);
      }

      this.tool_callbacks?.onExecuteComplete?.(result, step);
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.tool_callbacks?.onExecuteError?.(err);
      return this.execute_fallback(step.tool, processed_args);
    }
  }

  private async execute_fallback(
    tool_name: string,
    args: string
  ): Promise<string> {
    const content = `The tool "${tool_name}" failed to execute with args: "${args}". 
    Please provide the best possible answer using your knowledge.`;

    const result = await this.fallback_ai.get_completion(
      [{ role: 'user', content }],
      undefined,
      {
        onCompletion: (completion) => {
          this.tool_callbacks?.onCompletion?.(completion, 'worker', tool_name);
        },
      }
    );

    return `(Fallback) ${result}`;
  }
}

</document_content>
</document>
<document index="11">
<source>src/ReWOO/tools/llm.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/llm.tool.ts

import { AiGenerate, type AiConfig } from '../ai';
import type { Tool, ReWOOEventEmitter, ToolCallbacks } from '../types';

export class LlmTool implements Tool {
  name = 'LLM';
  description =
    'A pretrained LLM like yourself. Useful for general knowledge and reasoning.';
  private ai: AiGenerate;
  emitter?: ReWOOEventEmitter;
  private callbacks?: ToolCallbacks;

  constructor(ai_config: AiConfig, callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.callbacks = callbacks;
  }

  async execute(args: string): Promise<string> {
    try {
      this.callbacks?.onExecuteStart?.(args);

      const result = await this.ai.get_completion(
        [{ role: 'user', content: args }],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'tool', this.name);
          },
        }
      );

      this.callbacks?.onExecuteComplete?.(result);
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);
      throw err;
    }
  }
}

</document_content>
</document>
<document index="12">
<source>src/ReWOO/tools/memory_by_keyword.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/memory_by_keyword.tool.ts

import { AiGenerate, type AiConfig } from '../ai';
import { PostgresDatabase } from '../db/postgres_database';

import type { Tool } from '../types';

export class MemoryByKeywordTool implements Tool {
  name = 'MemoryByKeyword';
  description =
    'Retrieves memories related to the given query using semantic search.';
  private ai: AiGenerate;
  private db: PostgresDatabase;

  constructor(ai_config: AiConfig) {
    this.ai = new AiGenerate(ai_config);
    this.db = new PostgresDatabase();
    this.db.init().catch(console.error);
  }

  private clean_solution_text(text: string): string {
    return text.replace(/#E\d+|#[A-Za-z0-9_]+|\(#[A-Za-z0-9_]+\)/g, '');
  }

  async execute(args: string): Promise<string> {
    try {
      // Split terms and clean them
      const terms = args.split(',').map((term) => term.trim());

      // Get embeddings for each term
      const embeddings = await Promise.all(
        terms.map((term) => this.ai.get_embedding(term))
      );

      // Combine results from all terms
      const results = new Map();

      for (const embedding of embeddings) {
        const { rows } = await this.db.pool.query(
          `SELECT id, session_id, task, solution, metadata, 
           (embedding <=> $1) AS similarity
           FROM solutions
           WHERE (embedding <=> $1) < 2
           ORDER BY similarity ASC
           LIMIT 5`,
          [`[${embedding.join(',')}]`]
        );

        // Merge results, keeping best similarity score
        for (const row of rows) {
          const existing = results.get(row.id);
          if (!existing || existing.similarity > row.similarity) {
            results.set(row.id, row);
          }
        }
      }

      if (results.size === 0) {
        return 'No relevant memories found.';
      }

      return Array.from(results.values())
        .sort((a, b) => a.similarity - b.similarity)
        .slice(0, 5)
        .map(
          (r) =>
            `[Similarity: ${(1 - r.similarity).toFixed(2)}] Task: ${
              r.task
            }\nSolution: ${r.solution}\nSession: ${r.session_id}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Error searching memories:', error);
      return `Error searching memories: ${
        error instanceof Error ? error.message : String(error)
      }`;
    }
  }

  async cleanup(): Promise<void> {
    await this.db.cleanup();
  }
}

</document_content>
</document>
<document index="13">
<source>src/ReWOO/tools/recent_memory.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/recent_memory.tool.ts

import { PostgresDatabase } from '../db/postgres_database';

import type { Tool } from '../types';

export class RecentMemoryTool implements Tool {
  private static readonly DEFAULT_LIMIT = 10;
  private static readonly MAX_LIMIT = 20;

  name = 'RecentMemory';
  description =
    'Retrieves recent memories, optionally filtered by date range. Parameters:\n' +
    '- from_date: ISO format date to filter from\n' +
    '- to_date: ISO format date to filter to\n' +
    '- limit: Maximum number of records to return (default: 10, max: 20)';
  private db: PostgresDatabase;

  constructor() {
    this.db = new PostgresDatabase();
    this.db.init().catch(console.error);
  }

  async execute(args: string): Promise<string> {
    try {
      // Parse args as JSON to get optional parameters
      const params = args ? JSON.parse(args) : {};
      const {
        from_date,
        to_date,
        limit = RecentMemoryTool.DEFAULT_LIMIT,
      } = params;

      // Validate limit is a positive number
      const validated_limit = Math.max(
        1,
        Math.min(
          RecentMemoryTool.MAX_LIMIT,
          Number(limit) || RecentMemoryTool.DEFAULT_LIMIT
        )
      );

      let query = `
        SELECT id, session_id, task, solution, metadata, created_at
        FROM solutions
      `;
      const query_params: any[] = [];

      if (from_date || to_date) {
        const conditions: string[] = [];

        if (from_date) {
          conditions.push('created_at >= $' + (query_params.length + 1));
          query_params.push(from_date);
        }

        if (to_date) {
          conditions.push('created_at <= $' + (query_params.length + 1));
          query_params.push(to_date);
        }

        query += ' WHERE ' + conditions.join(' AND ');
      }

      query += ' ORDER BY created_at DESC LIMIT $' + (query_params.length + 1);
      query_params.push(validated_limit);

      const { rows } = await this.db.pool.query(query, query_params);

      if (rows.length === 0) {
        return 'No memories found for the specified criteria.';
      }

      return rows
        .map(
          (r) =>
            `[${new Date(r.created_at).toISOString()}] Task: ${
              r.task
            }\nSolution: ${r.solution}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Error fetching memories:', error);
      return `Error fetching memories: ${
        error instanceof Error ? error.message : String(error)
      }`;
    }
  }

  async cleanup(): Promise<void> {
    await this.db.cleanup();
  }
}

</document_content>
</document>
<document index="14">
<source>src/ReWOO/tools/search.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/search.tool.ts

import { Tool } from '../types';

export class SearchTool implements Tool {
  name = 'Search';
  description =
    'Searches the web. Useful for specific and up-to-date information.';
  private api_key: string;

  constructor(tavily_api_key: string) {
    this.api_key = tavily_api_key;
  }

  async execute(query: string): Promise<string> {
    try {
      const response = await fetch('https://api.tavily.com/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this.api_key}`,
        },
        body: JSON.stringify({
          query,
          sort_by: 'relevance',
        }),
      });

      if (!response.ok) {
        throw new Error(
          `Search API returned ${response.status}: ${response.statusText}`
        );
      }

      const data = await response.json();

      // Format the search results
      return data.results
        .map(
          (result: any) =>
            `[${result.title}]\n${result.content}\nURL: ${result.url}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Search API error:', error);
      throw error;
    }
  }
}

</document_content>
</document>
<document index="15">
<source>src/ReWOO/docs/events.md</source>
<document_content>
# ReWOO Callbacks and Events System

## Overview

ReWOO implements a two-layer event system built on Node's EventEmitter:

1. Low-level tool events (tool_start, tool_complete, error)
2. High-level process events (plan, solve)

The system provides granular control through callbacks while maintaining a pub/sub event architecture.

## Event Types

### Core Events

```typescript
type EventType =
  | 'tool_start' // Tool execution starting
  | 'tool_complete' // Tool execution completed
  | 'plan' // Planning phase complete
  | 'solve' // Solution phase complete
  | 'error' // Error occurred
  | 'completion'; // AI completion received
```

### Event Context

Each event includes execution context:

```typescript
interface ExecutionContext {
  session_id: string;
  task: string;
  step?: Step;
  tool?: string;
  args?: string;
  state?: State;
}
```

## Callback Interfaces

### Tool Callbacks

```typescript
interface ToolCallbacks {
  onExecuteStart?: (args: string) => void;
  onExecuteComplete?: (result: string, step?: Step) => void;
  onExecuteError?: (error: Error) => void;
  onCompletion?: (completion: CompletionWithRequestId) => void;
}
```

### ReWOO Callbacks

```typescript
interface ReWOOCallbacks {
  onPlan?: (state: State) => void;
  onToolExecute?: (step: Step, result: string) => void;
  onSolve?: (state: State) => void;
  onError?: (error: Error, state: State) => void;
}
```

## Usage Examples

### Registering Callbacks

```typescript
const rewoo = new ReWOO(ai_config, tools, {
  onPlan: (state) => {
    console.log('Plan created:', state.plan_string);
  },
  onToolExecute: (step, result) => {
    console.log(`Tool ${step.tool} executed:`, result);
  },
  onSolve: (state) => {
    console.log('Solution found:', state.result);
  },
  onError: (error) => {
    console.error('Error occurred:', error);
  },
});
```

### Tool Event Handling

Tools don't emit events directly. Instead, the Worker class manages tool execution and event handling:

```typescript
// Worker class handles tool execution and events
class Worker {
  private tool_callbacks?: ToolCallbacks;

  async execute_step(
    step: Step,
    results: Record<string, string> = {}
  ): Promise<string> {
    // Notify start of execution
    this.tool_callbacks?.onExecuteStart?.(processed_args);

    try {
      const result = await tool.execute(processed_args);

      // Notify completion
      this.tool_callbacks?.onExecuteComplete?.(result, step);
      return result;
    } catch (error) {
      // Notify error
      this.tool_callbacks?.onExecuteError?.(err);
      return this.execute_fallback(step.tool, processed_args);
    }
  }
}

// Tools that use AI receive callbacks through AiGenerate
class LlmTool implements Tool {
  async execute(args: string): Promise<string> {
    return await this.ai.get_completion(
      [{ role: 'user', content: args }],
      undefined,
      {
        onCompletion: (completion) => {
          this.callbacks?.onCompletion?.(completion, 'tool', this.name);
        },
      }
    );
  }
}
```

The event flow is:

1. Worker receives tool callbacks in constructor
2. Worker executes tools and triggers appropriate callbacks
3. Tools using AI pass completion callbacks through AiGenerate
4. ReWOO class maps these callbacks to high-level events

## Event Flow

1. **Tool Execution**

   - Tool starts ‚Üí `tool_start` event
   - Tool completes ‚Üí `tool_complete` event
   - Tool errors ‚Üí `error` event

2. **Planning Phase**

   - Plan created ‚Üí `plan` event
   - Plan executed ‚Üí Series of tool events

3. **Solution Phase**
   - Solution found ‚Üí `solve` event
   - Process complete

## Best Practices

1. **Error Handling**

   - Always include error context in error events
   - Use the error callback for graceful degradation
   - Implement fallback behavior where appropriate

2. **Event Cleanup**

   - Remove listeners when no longer needed
   - Clean up tool emitters during shutdown
   - Implement cleanup methods in tools

3. **State Management**
   - Include relevant state in event context
   - Maintain immutable state copies
   - Use state snapshots for event history

## Implementation Details

### Event Emission

The ReWOO class extends EventEmitter and overrides the emit method:

```typescript
emit<K extends keyof ReWOOEventMap>(
  event: K,
  args: ReWOOEventMap[K]
): boolean {
  this.callbacks?.onEvent?.(args);
  return super.emit(event, args);
}
```

### Event Mapping

Events are mapped to callbacks through the central event dispatcher:

```typescript
private emit_execution_event(event: ExecutionEvent): void {
  this.emit('rewoo:event', event);

  switch (event.type) {
    case 'plan':
      this.callbacks?.onPlan?.(event.context.state!);
      break;
    case 'tool_complete':
      if (event.context.step) {
        this.callbacks?.onToolExecute?.(
          event.context.step,
          event.data as string
        );
      }
      break;
    // ... other cases
  }
}
```

## Notes

- Events are type-safe through TypeScript interfaces
- Callbacks can be used for logging, monitoring, and debugging
- The system is extensible for custom event types
- Event context provides full execution traceability

</document_content>
</document>
<document index="16">
<source>src/ReWOO/docs/source_map.txt</source>
<document_content>
<documents>
<document index="1">
<source>src/ReWOO/ai.ts</source>
<document_content>
// ~/src/ReWOO/ai.ts
// class for AI generation tasks

import OpenAI from 'openai';

import type { AiRetryNotification, AiCallbacks } from './types';

import type {
  ChatCompletionMessageParam,
  ChatCompletionCreateParamsBase,
} from 'openai/resources/chat/completions';

export interface AiConfig {
  base_url?: string;
  api_key: string;
  model: string;
  max_tokens?: number | null;
  temperature?: number;
  timeout_ms?: number;
  max_retries?: number;
}

export class AiError extends Error {
  constructor(
    message: string,
    public readonly attempt?: number,
    public readonly status?: number,
    public readonly headers?: Record<string, string>,
    public readonly errorDetails?: Record<string, any>
  ) {
    super(message);
    this.name = 'AiError';
  }
}

// New error class for content moderation issues
export class ContentModerationError extends AiError {
  constructor(
    message: string,
    attempt?: number,
    status?: number,
    headers?: Record<string, string>,
    errorDetails?: Record<string, any>
  ) {
    super(message, attempt, status, headers, errorDetails);
    this.name = 'ContentModerationError';
  }
}

export class AiGenerate {
  protected readonly openai: OpenAI;
  protected readonly config: Required<AiConfig>;

  protected abort_controller: AbortController | null = null;
  protected messages: ChatCompletionMessageParam[] = [];

  constructor(config: AiConfig) {
    this.openai = new OpenAI({
      baseURL: config.base_url,
      apiKey: config.api_key,
    });

    this.config = {
      model: config.model,
      max_tokens: config.max_tokens ?? 8192,
      temperature: config.temperature ?? 0.5,
      timeout_ms: config.timeout_ms ?? 10000,
      max_retries: config.max_retries ?? 3,
      base_url: config.base_url ?? 'https://api.openai.com/v1',
      api_key: config.api_key,
    };
  }

  public async get_completion(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    let attempt = 0;
    let last_error: AiError | Error | null = null;

    while (attempt < this.config.max_retries) {
      try {
        return await this.execute_with_timeout(
          messages,
          response_format,
          callbacks
        );
      } catch (error) {
        // Extract OpenAI API error details if available
        if (error instanceof OpenAI.APIError) {
          const status = error.status;
          const headers = error.headers as Record<string, string>;
          const errorDetails = {
            type: error.type,
            code: error.code,
            param: error.param,
            message: error.message,
          };

          // Check for content moderation errors
          if (
            error.code === 'content_filter' ||
            error.message.includes('content management policy') ||
            error.message.includes('violates OpenAI') ||
            error.message.includes('content policy') ||
            error.message.includes('flagged') ||
            error.message.includes('moderation')
          ) {
            // Don't retry content moderation errors
            throw new ContentModerationError(
              error.message,
              attempt + 1,
              status,
              headers,
              errorDetails
            );
          }

          last_error = new AiError(
            error.message,
            attempt + 1,
            status,
            headers,
            errorDetails
          );
        } else {
          last_error =
            error instanceof Error ? error : new Error(String(error));
        }

        if (last_error.name === 'AbortError') {
          throw last_error;
        }

        if (!(await this.handle_retry(++attempt, last_error, callbacks))) {
          break;
        }
      }
    }

    if (last_error instanceof AiError) {
      throw last_error;
    } else {
      throw new AiError(
        `Failed after ${this.config.max_retries} attempts. Last error: ${last_error?.message}`,
        attempt
      );
    }
  }

  protected async execute_with_timeout(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    this.abort_controller = new AbortController();

    const timeout_promise = new Promise<never>((_, reject) => {
      setTimeout(() => {
        const error = new AiError(
          `Request timed out after ${this.config.timeout_ms}ms`
        );
        reject(error);
      }, this.config.timeout_ms);
    });

    try {
      return await Promise.race([
        this.execute(messages, response_format, callbacks),
        timeout_promise,
      ]);
    } finally {
      this.abort_controller = null;
    }
  }

  protected async execute(
    messages: ChatCompletionMessageParam[],
    response_format?: ChatCompletionCreateParamsBase['response_format'],
    callbacks?: AiCallbacks
  ): Promise<string> {
    const completion = await this.openai.chat.completions.create(
      {
        model: this.config.model,
        messages,
        max_tokens: this.config.max_tokens,
        temperature: this.config.temperature,
        response_format: response_format,
      },
      {
        signal: this.abort_controller?.signal,
      }
    );

    // Notify via callback instead of event
    callbacks?.onCompletion?.(completion);

    return completion.choices[0]?.message?.content ?? '';
  }

  protected async handle_retry(
    attempt: number,
    error: Error,
    callbacks?: AiCallbacks
  ): Promise<boolean> {
    if (attempt >= this.config.max_retries) {
      return false;
    }

    const backoff_ms = Math.min(
      1000 * Math.pow(2, attempt) + Math.random() * 1000,
      10000
    );

    const notification: AiRetryNotification = {
      type: 'retry',
      attempt,
      backoff_ms,
      error: error.message,
    };

    // Add additional error details if available
    if (error instanceof AiError) {
      notification.status = error.status;
      notification.headers = error.headers;
      notification.errorDetails = error.errorDetails;
    }

    // Notify via callback instead of event
    callbacks?.onRetry?.(notification);

    await new Promise((resolve) => setTimeout(resolve, backoff_ms));
    return true;
  }

  public async get_embedding(text: string): Promise<number[]> {
    try {
      const response = await this.openai.embeddings.create({
        model: 'text-embedding-ada-002',
        input: text,
      });
      return response.data[0].embedding;
    } catch (error) {
      console.error('Error getting embedding:', error);
      throw error;
    }
  }

  public abort(): void {
    this.abort_controller?.abort();
  }

  public add_message(message: ChatCompletionMessageParam): void {
    this.messages.push(message);
  }

  public get_messages(): ChatCompletionMessageParam[] {
    return [...this.messages];
  }

  public reset_messages(): void {
    // Keep only the first message (system prompt) if it exists
    this.messages = this.messages.length > 0 ? [this.messages[0]] : [];
  }

  public cleanup(): void {
    // Abort any pending requests
    this.abort();

    // Clear message history to help garbage collection
    this.messages = [];
  }
}

</document_content>
</document>
<document index="2">
<source>src/ReWOO/cli.ts</source>
<document_content>
// ~/src/ReWOO/cli.ts

import dotenv from 'dotenv';
import readline from 'readline';
import fs from 'fs';
import path from 'path';

import { format_state_as_markdown } from './helpers';
import { MemoryService } from './services/memory_service';
import { ReWOO } from './rewoo';

import { LlmTool } from './tools/llm.tool';
import { MemoryByKeywordTool } from './tools/memory_by_keyword.tool';
import { RecentMemoryTool } from './tools/recent_memory.tool';
import { SearchTool } from './tools/search.tool';

dotenv.config();

function create_cli() {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const ai_config = {
    api_key: process.env.CEREBRAS_API_KEY || '',
    base_url: 'https://api.cerebras.ai/v1',
    model: 'llama-3.3-70b',
    temperature: 0.5,
  };

  const ai_embedding_config = {
    api_key: process.env.OPENAI_API_KEY || '',
    model: 'gpt-4o-mini',
    temperature: 0.7,
  };

  // Initialize tools
  const llm_tool = new LlmTool(ai_config);
  const search_tool = new SearchTool(process.env.TAVILY_API_KEY || '');
  const memory_by_keyword_tool = new MemoryByKeywordTool(ai_embedding_config);
  const recent_memory_tool = new RecentMemoryTool();

  const memory_service = new MemoryService(ai_embedding_config);

  // Create ReWOO instance
  const rewoo = new ReWOO(
    ai_config,
    [llm_tool, search_tool, memory_by_keyword_tool, recent_memory_tool],
    {
      onPlan: (state) => {
        console.log('\nüîç Plan created:');
        // if (state.steps) {
        //   state.steps.forEach((step, index) => {
        //     console.log(`  ${index + 1}. ${step.plan}`);
        //     console.log(`     Tool: ${step.tool}[${step.args}]`);
        //   });
        // }
      },
      onToolExecute: (step, result) => {
        console.log(`\nüîß Executing step: ${step.variable}`);
        console.log(`   Plan: ${step.plan}`);
        console.log(`   Tool: ${step.tool}[${step.args}]`);
      },
      onSolve: async (state) => {
        console.log('\n‚úÖ Solution found');

        // Log session state as markdown
        const log_dir = path.join(__dirname, 'logs');
        const log_file = path.join(log_dir, `${rewoo.session_id}_log.md`);
        const markdown = format_state_as_markdown(state);
        await fs.promises.writeFile(log_file, markdown);
        console.log(`üìù Session logged to: ${log_file}`);
      },
      onError: (error) => console.error('\n‚ùå Error:', error.message),
    }
  );

  console.log('üöÄ ReWOO CLI Started - Enter a task or type "q" to quit');
  console.log(`üìå Session ID: ${rewoo.session_id}`);

  function prompt_user() {
    rl.question('\nüìù Enter your task: ', async (task) => {
      if (task.toLowerCase() === 'q') {
        await memory_service.cleanup();
        rl.close();
        return;
      }

      // Skip empty tasks and re-prompt
      if (!task.trim()) {
        console.log('‚ùå Task cannot be empty. Please try again.');
        prompt_user();
        return;
      }

      try {
        console.log(`\n‚è≥ Processing task: "${task}"`);
        const result = await rewoo.process(task);

        console.log('\nüìä Result:');
        console.log(result.result);

        // Store the solution
        if (result.result) {
          await memory_service.store_solution(
            rewoo.session_id,
            task,
            result.result,
            {
              steps_count: result.steps?.length || 0,
              errors: result.errors?.length || 0,
            }
          );
        }

        prompt_user();
      } catch (error) {
        console.error('‚ùå Error:', error);
        prompt_user();
      }
    });
  }

  prompt_user();

  // Handle process termination
  process.on('SIGINT', async () => {
    console.log('\nExiting...');
    await memory_service.cleanup();
    process.exit(0);
  });
}

if (require.main === module) {
  create_cli();
}

export { create_cli };

</document_content>
</document>
<document index="3">
<source>src/ReWOO/helpers.ts</source>
<document_content>
// ~/src/ReWOO/helpers.ts

import { State } from './types';

function escape_markdown(text: string): string {
  // Escape special markdown characters
  return text.replace(/[_*`[\]()~>#+=|{}.!-]/g, '\\$&');
}

function escape_code_block(text: string): string {
  // Escape backticks and ensure no ``` sequences
  return text.replace(/`/g, '\\`').replace(/```/g, '\\`\\`\\`');
}

export function format_state_as_markdown(state: State): string {
  const md: string[] = [];

  // Header with session info
  md.push(`# ReWOO Session Log\n`);
  md.push(`**Session ID:** \`${escape_code_block(state.session_id)}\`\n`);
  md.push(
    `**Timestamp:** ${new Date(state.timestamp || Date.now()).toISOString()}\n`
  );
  md.push(`**Task:** ${escape_markdown(state.task)}\n`);

  // Plan section
  if (state.plan_string) {
    md.push(`\n## Plan\n\n${escape_markdown(state.plan_string)}\n`);
  }

  // Steps section
  if (state.steps?.length) {
    md.push(`\n## Execution Steps\n`);
    state.steps.forEach((step, index) => {
      md.push(`\n### Step ${index + 1}\n`);
      md.push(`- **Tool:** \`${escape_code_block(step.tool)}\``);
      md.push(`- **Variable:** \`${escape_code_block(step.variable)}\``);
      md.push(`- **Plan:** ${escape_markdown(step.plan)}`);
      if (step.args) {
        md.push(`- **Arguments:** \`${escape_code_block(step.args)}\``);
      }
    });
  }

  // Results section
  if (state.results) {
    md.push(`\n## Results\n`);
    Object.entries(state.results).forEach(([variable, result]) => {
      md.push(`\n### ${escape_markdown(variable)}\n`);
      md.push(`\`\`\`\n${escape_code_block(result)}\n\`\`\`\n`);
    });
  }

  // Final Result section
  if (state.result) {
    md.push(`\n## Final Result\n\n${escape_markdown(state.result)}\n`);
  }

  // Errors section (if any)
  if (state.errors?.length) {
    md.push(`\n## Errors\n`);
    state.errors.forEach((error, index) => {
      md.push(`\n### Error ${index + 1}\n`);
      md.push(`\`\`\`\n${escape_code_block(error)}\n\`\`\`\n`);
    });
  }

  // Token Usage section
  if (state.token_usage?.length) {
    md.push(`\n## Token Usage\n`);
    md.push(`| Source | Tool | Prompt | Completion | Total |`);
    md.push(`|--------|------|---------|------------|--------|`);
    state.token_usage.forEach((usage) => {
      md.push(
        `| ${usage.source} | ${usage.tool_name || '-'} | ${
          usage.prompt_tokens
        } | ${usage.completion_tokens} | ${usage.total_tokens} |`
      );
    });

    // Add totals row
    const totals = state.token_usage.reduce(
      (acc, curr) => ({
        prompt_tokens: acc.prompt_tokens + curr.prompt_tokens,
        completion_tokens: acc.completion_tokens + curr.completion_tokens,
        total_tokens: acc.total_tokens + curr.total_tokens,
      }),
      { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    );

    md.push(
      `| **Total** | - | **${totals.prompt_tokens}** | **${totals.completion_tokens}** | **${totals.total_tokens}** |`
    );
  }

  return md.join('\n');
}

</document_content>
</document>
<document index="4">
<source>src/ReWOO/planner.ts</source>
<document_content>
// ~/src/ReWOO/planner.ts

import Handlebars from 'handlebars';

import { AiGenerate, type AiConfig } from './ai';

import type { State, Tool, ToolCallbacks } from './types';

// Handlebars template for the planner prompt
// prettier-ignore
const planner_template = Handlebars.compile(
`You are an expert planner that breaks tasks into sequential steps.

Today's date: {{today}}

Available tools:
{{#each tools}}
({{name}})[input]: {{description}}
{{/each}}

Create ONE sequential plan to solve the given task. Each step must follow this format exactly:
Plan: <description> #E<number> = <tool>[<args>]

Rules:
1. Create exactly ONE plan - do not revise or provide alternatives
2. Each step must have exactly one #E variable
3. Number steps sequentially starting at #E1
4. Each step must use an available tool
5. Later steps can reference earlier #E variables in their args

Examples:

Task: What are the latest developments in quantum computing?
Plan: Search for current quantum computing news. #E1 = Search[latest quantum computing breakthroughs 2024]
Plan: Analyze and summarize findings. #E2 = LLM[Summarize key developments from (#E1)]

Task: Explain how blockchain works
Plan: Search for technical details. #E1 = Search[blockchain technology explanation]
Plan: Create clear explanation. #E2 = LLM[Create beginner-friendly explanation from (#E1)]

Task: What is the capital of France?
Plan: Search for basic facts. #E1 = Search[capital of France facts]
Plan: Format response clearly. #E2 = LLM[Create concise response about Paris from (#E1)]

Task: What happened in the latest SpaceX launch?
Plan: Search recent news. #E1 = Search[latest SpaceX launch news]
Plan: Summarize key points. #E2 = LLM[Create summary of launch from (#E1)]

Task: Define the word "serendipity"
Plan: Search for definition. #E1 = Search[serendipity definition and examples]
Plan: Create clear explanation. #E2 = LLM[Format definition and examples from (#E1)]

Task: What did we discuss about climate change last week?
Plan: Search recent memory for climate discussions. #E1 = RecentMemory[climate change]
Plan: Analyze and summarize the conversation. #E2 = LLM[Create summary from (#E1)]

Task: What have I asked about artificial intelligence?
Plan: Search memory for AI-related queries. #E1 = MemoryByKeyword[artificial intelligence, AI, machine learning]
Plan: Create comprehensive overview. #E2 = LLM[Synthesize AI discussions from (#E1)]

Task: Find our previous discussions about renewable energy
Plan: Search memory for energy topics. #E1 = MemoryByKeyword[renewable energy, solar, wind power]
Plan: Organize key points. #E2 = LLM[Create structured summary from (#E1)]

Task: What background do we have on space exploration?
Plan: Retrieve space-related memories. #E1 = MemoryByKeyword[space exploration, NASA, astronomy]
Plan: Create contextual summary. #E2 = LLM[Build comprehensive context from (#E1)]

Task: What have we covered about quantum physics?
Plan: Get quantum physics discussions. #E1 = MemoryByKeyword[quantum physics, quantum mechanics]
Plan: Synthesize learning progress. #E2 = LLM[Create learning timeline from (#E1)]

Begin!
Describe your plans with rich details. Each Plan should be followed by only one #E.
Task: {{task}}`
);

export class PlannerAgent {
  private ai: AiGenerate;
  private tools: Tool[];
  private callbacks?: ToolCallbacks;
  private readonly regex_pattern =
    /Plan:\s*(.+)\s*(#E\d+)\s*=\s*(\w+)\s*\[([^\]]+)\]/g;

  constructor(ai_config: AiConfig, tools: Tool[], callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.tools = tools;
    this.callbacks = callbacks;
  }

  async create_plan(task: string): Promise<Partial<State>> {
    try {
      this.callbacks?.onExecuteStart?.('Creating execution plan');

      const system_message = this.create_system_prompt();
      const user_message = this.create_user_prompt(task);

      // Get the plan from the AI
      const result = await this.ai.get_completion(
        [
          { role: 'system', content: system_message },
          { role: 'user', content: user_message },
        ],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'planner');
          },
        }
      );

      // Parse the plan using regex
      const matches = Array.from(result.matchAll(this.regex_pattern));
      let plan_result: Partial<State>;

      if (matches.length === 0) {
        // Fallback to ensure at least one step
        plan_result = {
          plan_string: result,
          steps: [
            {
              plan: 'Get information about the topic',
              variable: '#E1',
              tool: 'LLM',
              args: task,
            },
          ],
        };

        this.callbacks?.onExecuteComplete?.('Created fallback plan');
      } else {
        const steps = matches.map((match) => ({
          plan: match[1].trim(),
          variable: match[2].trim(),
          tool: match[3].trim(),
          args: match[4].trim(),
        }));

        plan_result = {
          plan_string: result,
          steps,
        };

        this.callbacks?.onExecuteComplete?.(
          `Created plan with ${steps.length} steps`
        );
      }

      return plan_result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);

      // Return a minimal fallback plan
      return {
        plan_string: 'Error creating plan, using fallback',
        steps: [
          {
            plan: 'Get information about the topic',
            variable: '#E1',
            tool: 'LLM',
            args: task,
          },
        ],
      };
    }
  }

  private create_system_prompt(): string {
    return `You are an expert planner that breaks tasks into sequential steps.`;
  }

  private create_user_prompt(task: string): string {
    return planner_template({
      tools: this.tools,
      today: new Date().toLocaleDateString('en-GB'),
      task,
    });
  }
}

</document_content>
</document>
<document index="5">
<source>src/ReWOO/rewoo.ts</source>
<document_content>
// ~/src/ReWOO/rewoo.ts
//
// Event System Architecture:
// - Built on Node's EventEmitter for pub/sub event handling
// - Two-layer event system:
//   1. Low-level tool events (tool_start, tool_complete, error)
//   2. High-level process events (plan, solve)
// - Callbacks can be registered for granular control

import { EventEmitter } from 'events';
import { v4 as uuid } from 'uuid';

import { PlannerAgent } from './planner';
import { SolverAgent } from './solver';
import { Worker } from './worker';

import type { AiConfig } from './ai';
import type { EvidenceRecord, State } from './types';
import type { ExecutionEvent, ExecutionContext } from './types';
import type { ReWOOCallbacks, ReWOOEventEmitter, ReWOOEventMap } from './types';
import type { Tool, ToolCallbacks } from './types';

export class ReWOO extends EventEmitter implements ReWOOEventEmitter {
  private planner: PlannerAgent;
  private worker: Worker;
  private solver: SolverAgent;
  private callbacks?: ReWOOCallbacks;
  private state: State = { session_id: uuid(), task: '' };
  private tools: Tool[] = [];

  constructor(ai_config: AiConfig, tools: Tool[], callbacks?: ReWOOCallbacks) {
    super();
    this.callbacks = callbacks;
    this.tools = tools;

    // Increase event listener limit to handle tool-specific events
    this.setMaxListeners(tools.length + 10);

    // 1. Low-level tool events (tool_start, tool_complete, error)
    // 2. High-level process events (plan, solve)

    // Tool callback adapter maps low-level tool events to the event system

    const tool_callbacks: ToolCallbacks = {
      onExecuteStart: (args) => {
        this.emit_execution_event({
          type: 'tool_start',
          context: this.create_execution_context({ args }),
        });
      },
      onExecuteComplete: (result, step) => {
        this.emit_execution_event({
          type: 'tool_complete',
          context: this.create_execution_context({ step }),
          data: result,
        });
      },
      onExecuteError: (error) => {
        this.emit_execution_event({
          type: 'error',
          context: this.create_execution_context(),
          error,
        });
      },
      onCompletion: (completion, source = 'tool', tool_name?: string) => {
        const tokens = completion.usage
          ? {
              prompt: completion.usage.prompt_tokens,
              completion: completion.usage.completion_tokens,
              total: completion.usage.total_tokens,
            }
          : undefined;

        if (tokens) {
          if (!this.state.token_usage) {
            this.state.token_usage = [];
          }
          this.state.token_usage.push({
            source,
            tool_name,
            prompt_tokens: tokens.prompt,
            completion_tokens: tokens.completion,
            total_tokens: tokens.total,
          });
        }

        this.emit_execution_event({
          type: 'completion',
          context: this.create_execution_context(),
          data: {
            completion,
            source,
            tool_name,
            tokens,
          },
        });
      },
    };

    // Each tool gets access to the event emitter for publishing tool-specific events
    tools.forEach((tool) => {
      tool.emitter = this;
    });

    this.planner = new PlannerAgent(ai_config, tools, tool_callbacks);
    this.worker = new Worker(tools, ai_config, tool_callbacks);
    this.solver = new SolverAgent(ai_config, tool_callbacks);
  }

  // Override emit to ensure all events also trigger the generic onEvent callback
  emit<K extends keyof ReWOOEventMap>(
    event: K,
    args: ReWOOEventMap[K]
  ): boolean {
    this.callbacks?.onEvent?.(args);
    return super.emit(event, args);
  }

  // Central event dispatcher that maps execution events to specific callbacks
  // Handles both tool events and process lifecycle events
  private emit_execution_event(event: ExecutionEvent): void {
    // Emit the event
    this.emit('rewoo:event', event);

    // Map events to callbacks
    switch (event.type) {
      case 'plan':
        this.callbacks?.onPlan?.(event.context.state!);
        break;
      case 'tool_complete':
        if (event.context.step) {
          this.callbacks?.onToolExecute?.(
            event.context.step,
            event.data as string
          );
        }
        break;
      case 'solve':
        this.callbacks?.onSolve?.(event.context.state!);
        break;
      case 'error':
        if (event.error) {
          this.callbacks?.onError?.(event.error, event.context.state!);
        }
        break;
    }
  }

  // Creates consistent execution context for all events
  // Ensures events have access to current state and session info
  private create_execution_context(
    partial?: Partial<ExecutionContext>
  ): ExecutionContext {
    return {
      session_id: this.state.session_id,
      task: this.state.task,
      state: this.state,
      ...partial,
    };
  }

  // Comprehensive cleanup of event listeners and references
  // Prevents memory leaks and ensures proper teardown
  async cleanup(): Promise<void> {
    // Remove all event listeners
    this.removeAllListeners();

    // Remove emitter references from tools
    this.tools.forEach((tool) => {
      tool.emitter = undefined;
    });

    // Clear tools array
    this.tools = [];

    // Cleanup components that might have their own cleanup needs
    if ('cleanup' in this.worker && typeof this.worker.cleanup === 'function') {
      await this.worker.cleanup();
    }
    if (
      'cleanup' in this.planner &&
      typeof this.planner.cleanup === 'function'
    ) {
      await this.planner.cleanup();
    }
    if ('cleanup' in this.solver && typeof this.solver.cleanup === 'function') {
      await this.solver.cleanup();
    }

    // Clear callbacks
    this.callbacks = undefined;
  }

  // Add getters
  get session_id(): string {
    return this.state.session_id;
  }

  get current_state(): State {
    return { ...this.state };
  }

  // Getter for evidence records in a session; row-based
  // Maps to evidence table schema
  get evidence_records(): EvidenceRecord[] {
    return Object.entries(this.state.results || {}).map(
      ([variable, content], idx) => ({
        session_id: this.state.session_id,
        evidence_id: `E${idx + 1}`,
        content,
        created_at: this.state.timestamp || Date.now(),
        step_variable: variable,
      })
    );
  }

  async process(task: string): Promise<State> {
    this.state = {
      session_id: this.state.session_id,
      task,
      timestamp: Date.now(),
      errors: [],
    };

    try {
      const plan_result = await this.planner.create_plan(task);
      this.state = { ...this.state, ...plan_result };

      this.emit_execution_event({
        type: 'plan',
        context: this.create_execution_context(),
        data: plan_result,
      });

      if (this.state.steps && this.state.steps.length > 0) {
        this.state.results = {};

        for (const step of this.state.steps) {
          try {
            const result = await this.worker.execute_step(
              step,
              this.state.results
            );
            this.state.results[step.variable] = result;
          } catch (error) {
            const err =
              error instanceof Error ? error : new Error(String(error));
            this.state.results[step.variable] = `Error: ${err.message}`;

            this.emit_execution_event({
              type: 'error',
              context: this.create_execution_context({ step }),
              error: err,
            });
          }
        }
      }

      const solution = await this.solver.solve(this.state);
      this.state.result = solution;

      this.emit_execution_event({
        type: 'solve',
        context: this.create_execution_context(),
        data: solution,
      });

      return this.state;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));

      this.emit_execution_event({
        type: 'error',
        context: this.create_execution_context(),
        error: err,
      });

      if (!this.state.result) {
        try {
          const fallback = await this.solver.solve(this.state);
          this.state.result = fallback;
        } catch (solveError) {
          this.state.result = 'Unable to complete the task due to errors.';
        }
      }

      return this.state;
    }
  }
}

</document_content>
</document>
<document index="6">
<source>src/ReWOO/solver.ts</source>
<document_content>
// ~/src/ReWOO/solver.ts

import Handlebars from 'handlebars';

import { AiGenerate, type AiConfig } from './ai';

import type { State, ToolCallbacks } from './types';

// Template for the system prompt
const solver_template = `You are an expert at solving tasks using provided evidence.
Your role is to analyze the evidence and provide a clear, accurate solution.
If evidence is missing or incomplete, use your best judgment but be transparent about any assumptions.`;

// Template for the user prompt
// prettier-ignore
const user_template = Handlebars.compile(
`Solve the following task. To help you solve the task, we have made step-by-step Plans and retrieved corresponding Evidence for each Plan. Use them with caution since long evidence might contain irrelevant information. You will need to sift through the evidence to find the most relevant information to solve the problem.

{{plan_with_evidence}}

Now solve the task or problem according to the provided Evidence above. If evidence is missing or incomplete, use your best judgment.
Task: {{task}}

First, briefly summarize the key information from each piece of evidence. Then provide your final answer.`
);

export class SolverAgent {
  private ai: AiGenerate;
  private callbacks?: ToolCallbacks;

  constructor(ai_config: AiConfig, callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.callbacks = callbacks;
  }

  async solve(state: State): Promise<string> {
    try {
      this.callbacks?.onExecuteStart?.('Solving task with collected evidence');

      // Format the plan and evidence for better visibility
      let plan_with_evidence = '';

      if (state.steps && state.results) {
        for (const step of state.steps) {
          const result = state.results[step.variable] || '(No result)';
          const result_summary =
            result.length > 300
              ? result.substring(0, 300) + '... (truncated)'
              : result;

          plan_with_evidence += `Step: ${step.plan}\n`;
          plan_with_evidence += `Tool: ${step.tool}[${step.args}]\n`;
          plan_with_evidence += `**Evidence ${step.variable}:**\n${result_summary}\n\n`;
        }
      } else if (state.plan_string) {
        plan_with_evidence = state.plan_string;
      }

      const user_prompt = user_template({
        plan_with_evidence,
        task: state.task,
      });

      const result = await this.ai.get_completion(
        [
          { role: 'system', content: solver_template },
          { role: 'user', content: user_prompt },
        ],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'solver');
          },
        }
      );

      this.callbacks?.onExecuteComplete?.('Generated solution');
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);
      throw err;
    }
  }
}

</document_content>
</document>
<document index="7">
<source>src/ReWOO/todo.md</source>
<document_content>
## ReWOO Todos

- [ ] API key recycling
- [ ] Library tool
- [ ] Token counting (including from tools)
- [ ] Context from previous messages -> transform task

## Notes

</document_content>
</document>
<document index="8">
<source>src/ReWOO/tsconfig.json</source>
<document_content>
// ~/src/ReWOO/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "../../dist/rewoo",
    "declaration": true,
    "typeRoots": ["../../node_modules/@types", "types"]
  },
  "include": ["**/*"],
  "exclude": ["node_modules", "dist"]
}

</document_content>
</document>
<document index="9">
<source>src/ReWOO/types.ts</source>
<document_content>
// ~/src/ReWOO/types.ts
import { z } from 'zod';

import type { ChatCompletion } from 'openai/resources/chat';

// Step definition schema
export const StepSchema = z.object({
  plan: z.string(),
  variable: z.string().regex(/^#E\d+$/),
  tool: z.string(),
  args: z.string(),
});

export type Step = z.infer<typeof StepSchema>;

// State schema for tracking execution
export const StateSchema = z.object({
  session_id: z.string(),
  task: z.string(),
  plan_string: z.string().optional(),
  steps: z.array(StepSchema).optional(),
  results: z.record(z.string()).optional(),
  result: z.string().optional(),
  timestamp: z.number().optional(),
  errors: z.array(z.string()).optional(),
  token_usage: z
    .array(
      z.object({
        source: z.string(),
        tool_name: z.string().optional(),
        prompt_tokens: z.number(),
        completion_tokens: z.number(),
        total_tokens: z.number(),
      })
    )
    .optional(),
});

export type State = z.infer<typeof StateSchema>;

export interface ExecutionContext {
  session_id: string;
  task: string;
  step?: Step;
  tool?: string;
  args?: string;
  state?: State;
}

export interface CompletionEvent extends ExecutionEvent {
  type: 'completion';
  data: {
    completion: CompletionWithRequestId;
    source: 'planner' | 'solver' | 'worker' | 'tool';
    tool_name?: string;
    tokens?: {
      prompt: number;
      completion: number;
      total: number;
    };
  };
}

export interface ExecutionEvent {
  type:
    | 'tool_start'
    | 'tool_complete'
    | 'plan'
    | 'solve'
    | 'error'
    | 'completion';
  context: ExecutionContext;
  data?: unknown;
  error?: Error;
}

// Custom event map for type safety
export interface ReWOOEventMap {
  'rewoo:event': ExecutionEvent | CompletionEvent;
}

// Extend Node's EventEmitter with our custom events
export interface ReWOOEventEmitter extends NodeJS.EventEmitter {
  emit<K extends keyof ReWOOEventMap>(
    event: K,
    args: ReWOOEventMap[K]
  ): boolean;
  on<K extends keyof ReWOOEventMap>(
    event: K,
    listener: (args: ReWOOEventMap[K]) => void
  ): this;
}

// Core callbacks for all operations
export interface ReWOOCallbacks {
  onEvent?: (event: ExecutionEvent) => void;
}

// Tool interface for all tools to implement
export interface Tool {
  name: string;
  description: string;
  emitter?: ReWOOEventEmitter;
  execute(args: string): Promise<string>;
  cleanup?(): Promise<void>;
}

// Base completion type used throughout the application
export type CompletionWithRequestId = ChatCompletion & {
  _request_id?: string | null;
};

export interface AiRetryNotification {
  type: 'retry';
  attempt: number;
  backoff_ms: number;
  error: string;
  status?: number;
  headers?: Record<string, string>;
  errorDetails?: Record<string, any>;
}

// Core callbacks for AI operations
export interface AiCallbacks {
  onRetry?: (notification: AiRetryNotification) => void;
  onCompletion?: (
    completion: CompletionWithRequestId,
    source?: 'planner' | 'solver' | 'worker' | 'tool',
    tool_name?: string
  ) => void;
}

// Tool-specific callbacks extend AI callbacks
export interface ToolCallbacks extends AiCallbacks {
  onExecuteStart?: (args: string) => void;
  onExecuteComplete?: (result: string, step?: Step) => void;
  onExecuteError?: (error: Error) => void;
}

// ReWOO-specific callbacks extend AI callbacks
export interface ReWOOCallbacks extends AiCallbacks {
  onPlan?: (state: State) => void;
  onToolExecute?: (step: Step, result: string) => void;
  onSolve?: (state: State) => void;
  onError?: (error: Error, state: State) => void;
}

// EvidenceRecord is a record of evidence for a session
export interface EvidenceRecord {
  session_id: string;
  evidence_id: string; // E1, E2, etc.
  content: string;
  created_at: number;
  step_variable: string;
}

</document_content>
</document>
<document index="10">
<source>src/ReWOO/worker.ts</source>
<document_content>
// ~/src/ReWOO/worker.ts

import { AiGenerate, type AiConfig } from './ai';

import type { Step, Tool, ToolCallbacks } from './types';

export class Worker {
  private tools: Map<string, Tool>;
  private fallback_ai: AiGenerate;
  private tool_callbacks?: ToolCallbacks;

  constructor(
    tools: Tool[],
    ai_config: AiConfig,
    tool_callbacks?: ToolCallbacks
  ) {
    this.tool_callbacks = tool_callbacks;
    this.fallback_ai = new AiGenerate(ai_config);

    // Initialize tools map with callbacks
    this.tools = new Map(tools.map((tool) => [tool.name, tool]));
  }

  async cleanup(): Promise<void> {
    // Clear callbacks
    this.tool_callbacks = undefined;

    // Clear tools map
    this.tools.clear();

    // Cleanup any tools that have cleanup methods
    for (const tool of this.tools.values()) {
      if ('cleanup' in tool && typeof tool.cleanup === 'function') {
        await tool.cleanup();
      }
    }
  }

  async execute_step(
    step: Step,
    results: Record<string, string> = {}
  ): Promise<string> {
    // Process variable substitutions in the args
    let processed_args = step.args;
    for (const [key, value] of Object.entries(results)) {
      processed_args = processed_args.replace(key, value);
    }

    // Get the tool and execute it
    const tool = this.tools.get(step.tool);

    this.tool_callbacks?.onExecuteStart?.(processed_args);

    try {
      let result: string;

      if (!tool) {
        console.warn(`Tool "${step.tool}" not found, using fallback AI`);
        result = await this.execute_fallback(step.tool, processed_args);
      } else {
        // If it's an LLM tool, ensure it has the callbacks
        if (tool.name === 'LLM' && 'callbacks' in tool) {
          tool.callbacks = this.tool_callbacks;
        }
        result = await tool.execute(processed_args);
      }

      this.tool_callbacks?.onExecuteComplete?.(result, step);
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.tool_callbacks?.onExecuteError?.(err);
      return this.execute_fallback(step.tool, processed_args);
    }
  }

  private async execute_fallback(
    tool_name: string,
    args: string
  ): Promise<string> {
    const content = `The tool "${tool_name}" failed to execute with args: "${args}". 
    Please provide the best possible answer using your knowledge.`;

    const result = await this.fallback_ai.get_completion(
      [{ role: 'user', content }],
      undefined,
      {
        onCompletion: (completion) => {
          this.tool_callbacks?.onCompletion?.(completion, 'worker', tool_name);
        },
      }
    );

    return `(Fallback) ${result}`;
  }
}

</document_content>
</document>
<document index="11">
<source>src/ReWOO/tools/llm.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/llm.tool.ts

import { AiGenerate, type AiConfig } from '../ai';
import type { Tool, ReWOOEventEmitter, ToolCallbacks } from '../types';

export class LlmTool implements Tool {
  name = 'LLM';
  description =
    'A pretrained LLM like yourself. Useful for general knowledge and reasoning.';
  private ai: AiGenerate;
  emitter?: ReWOOEventEmitter;
  private callbacks?: ToolCallbacks;

  constructor(ai_config: AiConfig, callbacks?: ToolCallbacks) {
    this.ai = new AiGenerate(ai_config);
    this.callbacks = callbacks;
  }

  async execute(args: string): Promise<string> {
    try {
      this.callbacks?.onExecuteStart?.(args);

      const result = await this.ai.get_completion(
        [{ role: 'user', content: args }],
        undefined,
        {
          onCompletion: (completion) => {
            this.callbacks?.onCompletion?.(completion, 'tool', this.name);
          },
        }
      );

      this.callbacks?.onExecuteComplete?.(result);
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.callbacks?.onExecuteError?.(err);
      throw err;
    }
  }
}

</document_content>
</document>
<document index="12">
<source>src/ReWOO/tools/memory_by_keyword.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/memory_by_keyword.tool.ts

import { AiGenerate, type AiConfig } from '../ai';
import { PostgresDatabase } from '../db/postgres_database';

import type { Tool } from '../types';

export class MemoryByKeywordTool implements Tool {
  name = 'MemoryByKeyword';
  description =
    'Retrieves memories related to the given query using semantic search.';
  private ai: AiGenerate;
  private db: PostgresDatabase;

  constructor(ai_config: AiConfig) {
    this.ai = new AiGenerate(ai_config);
    this.db = new PostgresDatabase();
    this.db.init().catch(console.error);
  }

  private clean_solution_text(text: string): string {
    return text.replace(/#E\d+|#[A-Za-z0-9_]+|\(#[A-Za-z0-9_]+\)/g, '');
  }

  async execute(args: string): Promise<string> {
    try {
      // Split terms and clean them
      const terms = args.split(',').map((term) => term.trim());

      // Get embeddings for each term
      const embeddings = await Promise.all(
        terms.map((term) => this.ai.get_embedding(term))
      );

      // Combine results from all terms
      const results = new Map();

      for (const embedding of embeddings) {
        const { rows } = await this.db.pool.query(
          `SELECT id, session_id, task, solution, metadata, 
           (embedding <=> $1) AS similarity
           FROM solutions
           WHERE (embedding <=> $1) < 2
           ORDER BY similarity ASC
           LIMIT 5`,
          [`[${embedding.join(',')}]`]
        );

        // Merge results, keeping best similarity score
        for (const row of rows) {
          const existing = results.get(row.id);
          if (!existing || existing.similarity > row.similarity) {
            results.set(row.id, row);
          }
        }
      }

      if (results.size === 0) {
        return 'No relevant memories found.';
      }

      return Array.from(results.values())
        .sort((a, b) => a.similarity - b.similarity)
        .slice(0, 5)
        .map(
          (r) =>
            `[Similarity: ${(1 - r.similarity).toFixed(2)}] Task: ${
              r.task
            }\nSolution: ${r.solution}\nSession: ${r.session_id}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Error searching memories:', error);
      return `Error searching memories: ${
        error instanceof Error ? error.message : String(error)
      }`;
    }
  }

  async cleanup(): Promise<void> {
    await this.db.cleanup();
  }
}

</document_content>
</document>
<document index="13">
<source>src/ReWOO/tools/recent_memory.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/recent_memory.tool.ts

import { PostgresDatabase } from '../db/postgres_database';

import type { Tool } from '../types';

export class RecentMemoryTool implements Tool {
  private static readonly DEFAULT_LIMIT = 10;
  private static readonly MAX_LIMIT = 20;

  name = 'RecentMemory';
  description =
    'Retrieves recent memories, optionally filtered by date range. Parameters:\n' +
    '- from_date: ISO format date to filter from\n' +
    '- to_date: ISO format date to filter to\n' +
    '- limit: Maximum number of records to return (default: 10, max: 20)';
  private db: PostgresDatabase;

  constructor() {
    this.db = new PostgresDatabase();
    this.db.init().catch(console.error);
  }

  async execute(args: string): Promise<string> {
    try {
      // Parse args as JSON to get optional parameters
      const params = args ? JSON.parse(args) : {};
      const {
        from_date,
        to_date,
        limit = RecentMemoryTool.DEFAULT_LIMIT,
      } = params;

      // Validate limit is a positive number
      const validated_limit = Math.max(
        1,
        Math.min(
          RecentMemoryTool.MAX_LIMIT,
          Number(limit) || RecentMemoryTool.DEFAULT_LIMIT
        )
      );

      let query = `
        SELECT id, session_id, task, solution, metadata, created_at
        FROM solutions
      `;
      const query_params: any[] = [];

      if (from_date || to_date) {
        const conditions: string[] = [];

        if (from_date) {
          conditions.push('created_at >= $' + (query_params.length + 1));
          query_params.push(from_date);
        }

        if (to_date) {
          conditions.push('created_at <= $' + (query_params.length + 1));
          query_params.push(to_date);
        }

        query += ' WHERE ' + conditions.join(' AND ');
      }

      query += ' ORDER BY created_at DESC LIMIT $' + (query_params.length + 1);
      query_params.push(validated_limit);

      const { rows } = await this.db.pool.query(query, query_params);

      if (rows.length === 0) {
        return 'No memories found for the specified criteria.';
      }

      return rows
        .map(
          (r) =>
            `[${new Date(r.created_at).toISOString()}] Task: ${
              r.task
            }\nSolution: ${r.solution}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Error fetching memories:', error);
      return `Error fetching memories: ${
        error instanceof Error ? error.message : String(error)
      }`;
    }
  }

  async cleanup(): Promise<void> {
    await this.db.cleanup();
  }
}

</document_content>
</document>
<document index="14">
<source>src/ReWOO/tools/search.tool.ts</source>
<document_content>
// ~/src/ReWOO/tools/search.tool.ts

import { Tool } from '../types';

export class SearchTool implements Tool {
  name = 'Search';
  description =
    'Searches the web. Useful for specific and up-to-date information.';
  private api_key: string;

  constructor(tavily_api_key: string) {
    this.api_key = tavily_api_key;
  }

  async execute(query: string): Promise<string> {
    try {
      const response = await fetch('https://api.tavily.com/search', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${this.api_key}`,
        },
        body: JSON.stringify({
          query,
          sort_by: 'relevance',
        }),
      });

      if (!response.ok) {
        throw new Error(
          `Search API returned ${response.status}: ${response.statusText}`
        );
      }

      const data = await response.json();

      // Format the search results
      return data.results
        .map(
          (result: any) =>
            `[${result.title}]\n${result.content}\nURL: ${result.url}`
        )
        .join('\n\n');
    } catch (error) {
      console.error('Search API error:', error);
      throw error;
    }
  }
}

</document_content>
</document>
<document index="15">
<source>src/ReWOO/docs/events.md</source>
<document_content>
# ReWOO Callbacks and Events System

## Overview

ReWOO implements a two-layer event system built on Node's EventEmitter:

1. Low-level tool events (tool_start, tool_complete, error)
2. High-level process events (plan, solve)

The system provides granular control through callbacks while maintaining a pub/sub event architecture.

## Event Types

### Core Events

```typescript
type EventType =
  | 'tool_start' // Tool execution starting
  | 'tool_complete' // Tool execution completed
  | 'plan' // Planning phase complete
  | 'solve' // Solution phase complete
  | 'error' // Error occurred
  | 'completion'; // AI completion received
```

### Event Context

Each event includes execution context:

```typescript
interface ExecutionContext {
  session_id: string;
  task: string;
  step?: Step;
  tool?: string;
  args?: string;
  state?: State;
}
```

## Callback Interfaces

### Tool Callbacks

```typescript
interface ToolCallbacks {
  onExecuteStart?: (args: string) => void;
  onExecuteComplete?: (result: string, step?: Step) => void;
  onExecuteError?: (error: Error) => void;
  onCompletion?: (completion: CompletionWithRequestId) => void;
}
```

### ReWOO Callbacks

```typescript
interface ReWOOCallbacks {
  onPlan?: (state: State) => void;
  onToolExecute?: (step: Step, result: string) => void;
  onSolve?: (state: State) => void;
  onError?: (error: Error, state: State) => void;
}
```

## Usage Examples

### Registering Callbacks

```typescript
const rewoo = new ReWOO(ai_config, tools, {
  onPlan: (state) => {
    console.log('Plan created:', state.plan_string);
  },
  onToolExecute: (step, result) => {
    console.log(`Tool ${step.tool} executed:`, result);
  },
  onSolve: (state) => {
    console.log('Solution found:', state.result);
  },
  onError: (error) => {
    console.error('Error occurred:', error);
  },
});
```

### Tool Event Handling

Tools don't emit events directly. Instead, the Worker class manages tool execution and event handling:

```typescript
// Worker class handles tool execution and events
class Worker {
  private tool_callbacks?: ToolCallbacks;

  async execute_step(
    step: Step,
    results: Record<string, string> = {}
  ): Promise<string> {
    // Notify start of execution
    this.tool_callbacks?.onExecuteStart?.(processed_args);

    try {
      const result = await tool.execute(processed_args);

      // Notify completion
      this.tool_callbacks?.onExecuteComplete?.(result, step);
      return result;
    } catch (error) {
      // Notify error
      this.tool_callbacks?.onExecuteError?.(err);
      return this.execute_fallback(step.tool, processed_args);
    }
  }
}

// Tools that use AI receive callbacks through AiGenerate
class LlmTool implements Tool {
  async execute(args: string): Promise<string> {
    return await this.ai.get_completion(
      [{ role: 'user', content: args }],
      undefined,
      {
        onCompletion: (completion) => {
          this.callbacks?.onCompletion?.(completion, 'tool', this.name);
        },
      }
    );
  }
}
```

The event flow is:

1. Worker receives tool callbacks in constructor
2. Worker executes tools and triggers appropriate callbacks
3. Tools using AI pass completion callbacks through AiGenerate
4. ReWOO class maps these callbacks to high-level events

## Event Flow

1. **Tool Execution**

   - Tool starts ‚Üí `tool_start` event
   - Tool completes ‚Üí `tool_complete` event
   - Tool errors ‚Üí `error` event

2. **Planning Phase**

   - Plan created ‚Üí `plan` event
   - Plan executed ‚Üí Series of tool events

3. **Solution Phase**
   - Solution found ‚Üí `solve` event
   - Process complete

## Best Practices

1. **Error Handling**

   - Always include error context in error events
   - Use the error callback for graceful degradation
   - Implement fallback behavior where appropriate

2. **Event Cleanup**

   - Remove listeners when no longer needed
   - Clean up tool emitters during shutdown
   - Implement cleanup methods in tools

3. **State Management**
   - Include relevant state in event context
   - Maintain immutable state copies
   - Use state snapshots for event history

## Implementation Details

### Event Emission

The ReWOO class extends EventEmitter and overrides the emit method:

```typescript
emit<K extends keyof ReWOOEventMap>(
  event: K,
  args: ReWOOEventMap[K]
): boolean {
  this.callbacks?.onEvent?.(args);
  return super.emit(event, args);
}
```

### Event Mapping

Events are mapped to callbacks through the central event dispatcher:

```typescript
private emit_execution_event(event: ExecutionEvent): void {
  this.emit('rewoo:event', event);

  switch (event.type) {
    case 'plan':
      this.callbacks?.onPlan?.(event.context.state!);
      break;
    case 'tool_complete':
      if (event.context.step) {
        this.callbacks?.onToolExecute?.(
          event.context.step,
          event.data as string
        );
      }
      break;
    // ... other cases
  }
}
```

## Notes

- Events are type-safe through TypeScript interfaces
- Callbacks can be used for logging, monitoring, and debugging
- The system is extensible for custom event types
- Event context provides full execution traceability

</document_content>
</document>

</document_content>
</document>
<document index="17">
<source>src/ReWOO/logs/3dc4a232-c833-4bb8-ae6d-1d186957d591_log.md</source>
<document_content>
# ReWOO Session Log

**Session ID:** `3dc4a232-c833-4bb8-ae6d-1d186957d591`

**Timestamp:** 2025-03-09T09:19:46.143Z

**Task:** who is aftab hussain of Bolton College?


## Plan

Plan: Search for information about Aftab Hussain of Bolton College to gather background details\. \#E1 \= Search\[Aftab Hussain Bolton College\]

Plan: Use the search results to create a concise biography of Aftab Hussain, focusing on his role and achievements at Bolton College\. \#E2 \= LLM\[Create biography from \(\#E1\)\]

Plan: Investigate Aftab Hussain's professional and educational background to add depth to the biography\. \#E3 \= Search\[Aftab Hussain professional background education\]

Plan: Analyze the search results to identify any notable accomplishments, awards, or publications associated with Aftab Hussain\. \#E4 \= LLM\[Analyze accomplishments from \(\#E3\)\]

Plan: Combine the biography, background information, and notable accomplishments to create a comprehensive profile of Aftab Hussain\. \#E5 \= LLM\[Create comprehensive profile from \(\#E2\), \(\#E3\), \(\#E4\)\]


## Execution Steps


### Step 1

- **Tool:** `Search`
- **Variable:** `#E1`
- **Plan:** Search for information about Aftab Hussain of Bolton College to gather background details\.
- **Arguments:** `Aftab Hussain Bolton College`

### Step 2

- **Tool:** `LLM`
- **Variable:** `#E2`
- **Plan:** Use the search results to create a concise biography of Aftab Hussain, focusing on his role and achievements at Bolton College\.
- **Arguments:** `Create biography from (#E1)`

### Step 3

- **Tool:** `Search`
- **Variable:** `#E3`
- **Plan:** Investigate Aftab Hussain's professional and educational background to add depth to the biography\.
- **Arguments:** `Aftab Hussain professional background education`

### Step 4

- **Tool:** `LLM`
- **Variable:** `#E4`
- **Plan:** Analyze the search results to identify any notable accomplishments, awards, or publications associated with Aftab Hussain\.
- **Arguments:** `Analyze accomplishments from (#E3)`

### Step 5

- **Tool:** `LLM`
- **Variable:** `#E5`
- **Plan:** Combine the biography, background information, and notable accomplishments to create a comprehensive profile of Aftab Hussain\.
- **Arguments:** `Create comprehensive profile from (#E2), (#E3), (#E4)`

## Results


### \#E1

```
[Aftab Hussain - Bett UK]
Aftab Hussain. Learning Technology Manager, Bolton College. United Kingdom. Aftab Hussain has nearly 30 years of experience of managing learning technology
URL: https://uk.bettshow.com/speakers/aftab-hussain

[Bolton College ILT Projects - Aftab Hussain]
As the ILT and LRC Manager at Bolton College I am always keen to showcase the ILT projects that are underway across the College.
URL: http://www.aftabhussain.com/responsive-boltoncollege.html

[Aftab Hussain]
I have been pursuing a PhD by retrospective practice at The University of Bolton. On the 24th of November 2023 I passed my viva with non-major amendments.
URL: http://www.aftabhussain.com/

[Aftab Hussain on LinkedIn: Bolton College's chatbot platform ...]
Bolton College's chatbot platform enables teachers to set up a wide range of chatbots to support their students. For example, the following
URL: https://www.linkedin.com/posts/aftab-hussain-7145444_bolton-colleges-chatbot-platform-enables-activity-7292300797357228032-7VlZ

[Aftab Hussain's Post - LinkedIn]
Over the last few years I have been pursuing a PhD by retrospective practice at The University of Bolton. Last Friday I passed my viva with
URL: https://www.linkedin.com/posts/aftab-hussain-7145444_over-the-last-few-years-i-have-been-pursuing-activity-7135359714770452482-xQSM?trk=public_profile_like_view
```


### \#E2

```
Here is a biography for Aftab Hussain based on the provided information:

Aftab Hussain is a seasoned Learning Technology Manager with nearly 30 years of experience in managing learning technology. He is currently employed at Bolton College in the United Kingdom, where he serves as the ILT and LRC Manager. In this role, Aftab has been instrumental in overseeing various ILT projects across the college, showcasing his expertise and passion for innovative learning technologies.

Aftab has also been pursuing academic excellence, recently completing his PhD by retrospective practice at The University of Bolton. He successfully passed his viva with non-major amendments on November 24, 2023, a testament to his dedication and hard work.

In addition to his academic and professional accomplishments, Aftab has been at the forefront of implementing cutting-edge technologies at Bolton College. For instance, he has been involved in the development and implementation of the college's chatbot platform, which enables teachers to set up chatbots to support students in various ways.

Aftab is an active member of the educational community, frequently sharing his expertise and experiences through speaking engagements and online platforms, including LinkedIn. His work and achievements have been recognized, and he has been featured as a speaker at prominent events, such as the Bett UK conference.

Overall, Aftab Hussain is a respected and accomplished professional in the field of learning technology, with a strong track record of innovation, academic excellence, and leadership.
```


### \#E3

```
[Engr. Prof. Dr. Aftab Hussain - Professor and HoD - LinkedIn]
I am Dr. Aftab Hussain, a seasoned Electronic Engineer with a Ph.D. in Optical Engineering, residing in Islamabad, Pakistan. With a robust professional background, I specialize in Next-Generation Passive Optical Networks, Dense Wavelength Division Multiplexing (DWDM), and Synchronous Digital Hierarchy (SDH) systems. üéì Education:
URL: https://pk.linkedin.com/in/engrdraftabhussain

[Aftab Hussain - law.unimelb.edu.au]
Aftab has been providing professional services at the University of Melbourne for over two years. Prior to that, he was the Deputy Director (Technical) of Energy Projects at the National Transmission and Despatch Company, Pakistan, where he managed and executed the contracts with Independent Power Producers and other international stakeholders.
URL: https://law.unimelb.edu.au/constitutional-transformations/people/researchers/aftab-hussain

[Aftab Hussain - Director Research - Center for International Strategic ...]
Director Research at Center for International Strategic Studies Sindh ¬∑ Experienced Scholar with a demonstrated history of working in the higher education industry. Skilled in Analytical Skills, Stata, Research Design, Program Evaluation, and Lecturing. Strong research professional with a M.Phil focused in Defence and Strategic Studies from Quaid-e-Azam University, Islamabad. ¬∑ Experience
URL: https://pk.linkedin.com/in/aftab-hussain-45853a12

[PDF]
Aftab M. Hussain, Ph.D. Postdoctoral Fellow, Harvard University, Email: amhussain@seas.harvard.edu Cambridge, MA, USA. Mobile: +1-857-498-4077 Skype ID: aftab104 Summary Aftab Hussain has over 5 years of hands-on processing experience in a Class 100 cleanroom, along with in-
URL: https://scholar.harvard.edu/sites/scholar.harvard.edu/files/aftab_hussain/files/aftab_hussain_cv.pdf

[Dr. Aftab Hussain | Grand asian university of sialkot]
Aftab Hussain, Abdul Latif Memon and Abdul Qadir Ansari , "A Symmetric RZ-DPSK Based Colorless NG-PON using Optical Carrier Suppression Scheme" Publication: Journals, Mehran University Research Journal of Engineering & Technology, Volume 36, No. 1, January, 2017 [p-ISSN: 0254-7821, e-ISSN: 2413-7219]
URL: https://gaus.edu.pk/doctor-aftabhussain
```


### \#E4

```
Based on the provided information, here are the accomplishments of Dr. Aftab Hussain:

**Academic Achievements:**

1. Ph.D. in Optical Engineering
2. M.Phil in Defence and Strategic Studies from Quaid-e-Azam University, Islamabad
3. Postdoctoral Fellow at Harvard University

**Professional Experience:**

1. Professor and Head of Department (HoD) at a university (exact institution not specified)
2. Deputy Director (Technical) of Energy Projects at the National Transmission and Despatch Company, Pakistan
3. Director Research at Center for International Strategic Studies Sindh
4. Provided professional services at the University of Melbourne for over two years
5. Worked as a Postdoctoral Fellow at Harvard University

**Research and Publications:**

1. Published a research paper titled "A Symmetric RZ-DPSK Based Colorless NG-PON using Optical Carrier Suppression Scheme" in the Mehran University Research Journal of Engineering & Technology
2. Demonstrated expertise in Next-Generation Passive Optical Networks, Dense Wavelength Division Multiplexing (DWDM), and Synchronous Digital Hierarchy (SDH) systems

**Skills:**

1. Analytical Skills
2. Stata
3. Research Design
4. Program Evaluation
5. Lecturing

**Other Achievements:**

1. Managed and executed contracts with Independent Power Producers and international stakeholders at the National Transmission and Despatch Company, Pakistan
2. Worked in a Class 100 cleanroom with over 5 years of hands-on processing experience

Overall, Dr. Aftab Hussain has a strong background in electronic engineering, optical engineering, and research, with a demonstrated ability to work in academia, industry, and research institutions. His expertise in next-generation optical networks, DWDM, and SDH systems, as well as his experience in managing energy projects and providing professional services, make him a versatile and accomplished professional.
```


### \#E5

```
Here is a comprehensive profile for Dr. Aftab Hussain based on the provided information:

**Name:** Dr. Aftab Hussain

**Current Location:** Islamabad, Pakistan (also has connections to the United Kingdom, Australia, and the United States)

**Education:**

1. Ph.D. in Optical Engineering
2. M.Phil in Defence and Strategic Studies from Quaid-e-Azam University, Islamabad
3. Postdoctoral Fellow at Harvard University
4. Ph.D. by retrospective practice at The University of Bolton (recently completed, with viva passed on November 24, 2023)

**Professional Experience:**

1. Professor and Head of Department (HoD) at a university (exact institution not specified)
2. Deputy Director (Technical) of Energy Projects at the National Transmission and Despatch Company, Pakistan
3. Director Research at Center for International Strategic Studies Sindh
4. Provided professional services at the University of Melbourne for over two years
5. Worked as a Postdoctoral Fellow at Harvard University
6. Learning Technology Manager at Bolton College in the United Kingdom, where he serves as the ILT and LRC Manager
7. Researcher at the University of Melbourne

**Research and Publications:**

1. Published a research paper titled "A Symmetric RZ-DPSK Based Colorless NG-PON using Optical Carrier Suppression Scheme" in the Mehran University Research Journal of Engineering & Technology
2. Demonstrated expertise in Next-Generation Passive Optical Networks, Dense Wavelength Division Multiplexing (DWDM), and Synchronous Digital Hierarchy (SDH) systems
3. Contributed to the development and implementation of cutting-edge technologies, including a chatbot platform at Bolton College

**Skills:**

1. Analytical Skills
2. Stata
3. Research Design
4. Program Evaluation
5. Lecturing
6. Learning Technology Management
7. Project Management
8. Contract Management

**Other Achievements:**

1. Managed and executed contracts with Independent Power Producers and international stakeholders at the National Transmission and Despatch Company, Pakistan
2. Worked in a Class 100 cleanroom with over 5 years of hands-on processing experience
3. Featured as a speaker at prominent events, such as the Bett UK conference
4. Active member of the educational community, frequently sharing expertise and experiences through speaking engagements and online platforms, including LinkedIn

**Awards and Recognition:**

1. Successfully passed his viva with non-major amendments for his Ph.D. by retrospective practice at The University of Bolton

**Publications and Presentations:**

1. "A Symmetric RZ-DPSK Based Colorless NG-PON using Optical Carrier Suppression Scheme" (research paper)
2. Presentations at conferences, such as the Bett UK conference

**Professional Memberships:**

1. LinkedIn
2. Other professional networks and associations (not specified)

**Language Skills:**

1. English (fluent)
2. Other languages (not specified)

**Interests:**

1. Learning Technology
2. Optical Engineering
3. Next-Generation Passive Optical Networks
4. Dense Wavelength Division Multiplexing (DWDM)
5. Synchronous Digital Hierarchy (SDH) systems
6. Research and Development
7. Education and Academia

Overall, Dr. Aftab Hussain is a highly accomplished and versatile professional with a strong background in electronic engineering, optical engineering, and research. His expertise in next-generation optical networks, DWDM, and SDH systems, as well as his experience in managing energy projects and providing professional services, make him a respected and sought-after expert in his field.
```


## Final Result

Here's a brief summary of the key information from each piece of evidence:

\* \*\*Evidence \#E1\*\*: Aftab Hussain is a Learning Technology Manager at Bolton College in the United Kingdom, with nearly 30 years of experience in managing learning technology\.
\* \*\*Evidence \#E2\*\*: A biography of Aftab Hussain is created, highlighting his role as a Learning Technology Manager at Bolton College and his nearly 30 years of experience in managing learning technology\.
\* \*\*Evidence \#E3\*\*: This evidence appears to be about a different person, Dr\. Aftab Hussain, who is an Electronic Engineer with a Ph\.D\. in Optical Engineering, residing in Islamabad, Pakistan\.
\* \*\*Evidence \#E4\*\*: This evidence also appears to be about the Dr\. Aftab Hussain from Pakistan, highlighting his academic achievements, including a Ph\.D\. in Optical Engineering, and professional experience\.
\* \*\*Evidence \#E5\*\*: This evidence combines information to create a comprehensive profile of Dr\. Aftab Hussain, but it seems to be about the person from Pakistan, not the Aftab Hussain from Bolton College\.

Based on the evidence, it appears that there are two different individuals with the name Aftab Hussain\. The Aftab Hussain from Bolton College is a Learning Technology Manager with nearly 30 years of experience in managing learning technology\. The other Aftab Hussain is a Dr\. from Pakistan with a background in Electronic Engineering and Optical Engineering\.

My final answer to the task "who is Aftab Hussain of Bolton College?" is:

Aftab Hussain of Bolton College is a Learning Technology Manager with nearly 30 years of experience in managing learning technology, currently employed at Bolton College in the United Kingdom\.


## Token Usage

| Source | Tool | Prompt | Completion | Total |
|--------|------|---------|------------|--------|
| planner | - | 859 | 197 | 1056 |
| tool | LLM | 397 | 295 | 692 |
| tool | LLM | 604 | 397 | 1001 |
| tool | LLM | 1296 | 756 | 2052 |
| solver | - | 802 | 356 | 1158 |
| **Total** | - | **3958** | **2001** | **5959** |
</document_content>
</document>
<document index="18">
<source>src/ReWOO/logs/ea690c6f-ec4f-49c8-84c4-23164b3e393a_log.md</source>
<document_content>
# ReWOO Session Log

**Session ID:** `ea690c6f-ec4f-49c8-84c4-23164b3e393a`

**Timestamp:** 2025-03-09T08:52:03.652Z

**Task:** what is the principle of least surprise in programming?


## Plan

Plan: Search for the definition and explanation of the principle of least surprise in programming\. \#E1 \= Search\[principle of least surprise programming definition\]

Plan: Analyze and summarize the key points of the principle of least surprise, including its application and benefits in software development\. \#E2 \= LLM\[Summarize the principle of least surprise from \(\#E1\) and provide examples\]

Plan: Examine the relationship between the principle of least surprise and other programming principles, such as KISS \(Keep it Simple, Stupid\) and YAGNI \(You Ain't Gonna Need It\), to provide a comprehensive understanding\. \#E3 \= LLM\[Discuss the relationship between the principle of least surprise from \(\#E1\) and other programming principles\]

Plan: Retrieve relevant memories of previous discussions on programming principles to identify any connections or similarities with the principle of least surprise\. \#E4 \= MemoryByKeyword\[programming principles, software development, design patterns\]

Plan: Create a detailed explanation of the principle of least surprise, incorporating the analysis from \(\#E2\), the relationships with other principles from \(\#E3\), and any relevant memories from \(\#E4\), to provide a rich and comprehensive understanding\. \#E5 \= LLM\[Create a detailed explanation of the principle of least surprise from \(\#E1\), \(\#E2\), \(\#E3\), and \(\#E4\)\]


## Execution Steps


### Step 1

- **Tool:** `Search`
- **Variable:** `#E1`
- **Plan:** Search for the definition and explanation of the principle of least surprise in programming\.
- **Arguments:** `principle of least surprise programming definition`

### Step 2

- **Tool:** `LLM`
- **Variable:** `#E2`
- **Plan:** Analyze and summarize the key points of the principle of least surprise, including its application and benefits in software development\.
- **Arguments:** `Summarize the principle of least surprise from (#E1) and provide examples`

### Step 3

- **Tool:** `LLM`
- **Variable:** `#E3`
- **Plan:** Examine the relationship between the principle of least surprise and other programming principles, such as KISS \(Keep it Simple, Stupid\) and YAGNI \(You Ain't Gonna Need It\), to provide a comprehensive understanding\.
- **Arguments:** `Discuss the relationship between the principle of least surprise from (#E1) and other programming principles`

### Step 4

- **Tool:** `MemoryByKeyword`
- **Variable:** `#E4`
- **Plan:** Retrieve relevant memories of previous discussions on programming principles to identify any connections or similarities with the principle of least surprise\.
- **Arguments:** `programming principles, software development, design patterns`

### Step 5

- **Tool:** `LLM`
- **Variable:** `#E5`
- **Plan:** Create a detailed explanation of the principle of least surprise, incorporating the analysis from \(\#E2\), the relationships with other principles from \(\#E3\), and any relevant memories from \(\#E4\), to provide a rich and comprehensive understanding\.
- **Arguments:** `Create a detailed explanation of the principle of least surprise from (#E1), (#E2), (#E3), and (#E4)`

## Results


### \#E1

```
[The Principle of Least Surprise (Principle of Least ... - Medium]
Definition. The Principle of Least Surprise (POLA) is a design principle that states that a system or interface should behave to minimize surprises or confusion for users or programmers. This
URL: https://medium.com/@Masoncoding/the-principle-of-least-surprise-principle-of-least-astonishment-pola-3937e8ee051d

[Principle of Least Astonishment: A Software Design Guideline]
The Principle of Least Astonishment (POLA), also known as the Principle of Least Surprise, is a software design guideline that emphasizes the importance of designing software systems in a way that minimizes confusion and unexpected behavior for users and developers.
URL: https://deviq.com/principles/principle-of-least-astonishment/?trk=public_post_comment-text

[What is the Principle of Least Surprise? - Centercode]
The Principle of Least Surprise (or consistency principle) is the idea that a user shouldn't be surprised by the way an interaction or object works in an interface or design. This means prioritizing functionality and use over things like consistency to avoid astonishing or surprising your user. "In interface design, always do the least
URL: https://www.centercode.com/glossary/principle-of-least-surprise

[Principle of least astonishment - Wikipedia]
In user interface design and software design, [1] the principle of least astonishment (POLA), also known as principle of least surprise, [a] proposes that a component of a system should behave in a way that most users will expect it to behave, and therefore not astonish or surprise users. The following is a corollary of the principle: "If a necessary feature has a high astonishment factor, it
URL: https://en.wikipedia.org/wiki/Principle_of_least_astonishment

[The Principle of Least Astonishment | by Alex Yampolsky - UX Planet]
Let us take a closer look at the very definition of the word "system," so as to better understand how The Principle of Least Astonishment becomes a key part of the system design discussion. A Google search of the word system defines it as: 1. a set of connected things or parts forming a complex whole, in particular.
URL: https://uxplanet.org/the-principle-of-least-astonishment-bc3f67991510
```


### \#E2

```
The Principle of Least Surprise (POLA), also known as the Principle of Least Astonishment, is a design principle that aims to minimize surprises or confusion for users or programmers when interacting with a system or interface. The principle states that a system should behave in a way that is most expected by its users, avoiding unexpected behavior and astonishing or surprising interactions.

In essence, the principle suggests that designers should prioritize functionality, consistency, and predictability in their designs to ensure that users can easily understand and navigate the system. This means that the system should behave in a way that is intuitive, logical, and consistent with user expectations.

Here are some examples of the Principle of Least Surprise in action:

1. **Consistent navigation**: A website's navigation menu should be consistent across all pages, with the same layout, typography, and functionality. This ensures that users can easily find what they're looking for and navigate the site without surprises.
2. **Intuitive icon design**: Icons should be designed to be easily recognizable and intuitive. For example, a trash can icon should be used to delete items, not to save them.
3. **Predictable form behavior**: When filling out a form, users expect the "Submit" button to submit the form, not to clear the fields or take them to a different page.
4. **Standardized error messages**: Error messages should be clear, concise, and consistent in their formatting and language. This helps users quickly understand what went wrong and how to fix it.
5. **Consistent button behavior**: Buttons should behave consistently throughout a system. For example, a "Cancel" button should always cancel the current action, not confirm it.
6. **Logical sorting and filtering**: When sorting or filtering data, the system should behave in a way that is logical and consistent with user expectations. For example, sorting by date should sort in chronological order, not reverse chronological order.
7. **Clear and concise labeling**: Labels and headings should be clear, concise, and descriptive, avoiding ambiguity and confusion.

By following the Principle of Least Surprise, designers can create systems and interfaces that are intuitive, easy to use, and minimize user frustration. This, in turn, can lead to increased user satisfaction, engagement, and ultimately, a better overall user experience.

In contrast, violating the Principle of Least Surprise can lead to:

* User frustration and confusion
* Increased errors and mistakes
* Decreased user satisfaction and engagement
* Negative reviews and word-of-mouth

By prioritizing the Principle of Least Surprise in design, developers and designers can create systems that are more user-friendly, efficient, and effective, ultimately leading to a better user experience.
```


### \#E3

```
The Principle of Least Surprise (POLA), also known as the Principle of Least Astonishment, is a fundamental design principle that aims to minimize surprises or confusion for users and programmers when interacting with a system or interface. This principle is closely related to other programming principles, which together form a set of guidelines for designing intuitive, user-friendly, and maintainable software systems.

**Relationship with other programming principles:**

1. **KISS (Keep it Simple, Stupid) principle**: The POLA principle complements the KISS principle, which emphasizes simplicity and ease of use. By minimizing surprises, a system is more likely to be simple and easy to understand.
2. **YAGNI (You Ain't Gonna Need It) principle**: The POLA principle is related to YAGNI, which states that a feature should only be implemented if it is necessary. If a feature is not necessary, it may introduce unnecessary complexity and surprise users.
3. **DRY (Don't Repeat Yourself) principle**: The POLA principle is also connected to the DRY principle, which aims to avoid duplication of code or functionality. By avoiding duplication, a system is more likely to be consistent and less surprising to users.
4. **Separation of Concerns (SoC) principle**: The POLA principle is related to the SoC principle, which emphasizes the separation of different concerns or features within a system. By separating concerns, a system is more modular and easier to understand, reducing the likelihood of surprises.
5. **Consistency principle**: The POLA principle is closely related to the consistency principle, which states that a system should behave consistently and predictably. Consistency is a key aspect of minimizing surprises and making a system more intuitive to use.

**Benefits of the Principle of Least Surprise:**

1. **Improved user experience**: By minimizing surprises, a system is more likely to be intuitive and easy to use, leading to a better user experience.
2. **Reduced errors**: Surprises can lead to errors, so by minimizing surprises, a system is less likely to produce errors.
3. **Increased maintainability**: A system that is designed with the POLA principle in mind is more likely to be maintainable, as it is easier to understand and modify.
4. **Better scalability**: A system that is designed with the POLA principle in mind is more likely to be scalable, as it is easier to add new features without introducing surprises.

**Challenges and limitations:**

1. **Subjective nature**: The POLA principle is subjective, as what may be surprising to one user may not be surprising to another.
2. **Context-dependent**: The POLA principle is context-dependent, as what may be surprising in one context may not be surprising in another.
3. **Trade-offs**: The POLA principle may require trade-offs with other design principles, such as simplicity or performance.

In conclusion, the Principle of Least Surprise is a fundamental design principle that is closely related to other programming principles, such as KISS, YAGNI, DRY, SoC, and consistency. By minimizing surprises, a system is more likely to be intuitive, maintainable, and scalable, leading to a better user experience. However, the POLA principle is subjective and context-dependent, and may require trade-offs with other design principles.
```


### \#E4

```
[Similarity: 0.81] Task: How well regarded is the Sentry software tool for devs?
Solution: ### Evidence Summary
**Evidence :**
- Sentry Software has a rating of 5 stars based on reviews from real users in the Infrastructure Monitoring Tools market on Gartner Peer Insights.
- The number of reviews for Sentry is 3, which is significantly less than Datadog's 305 reviews.
- Datadog, a comparable tool, has a rating of 4.5 stars.

### Final Answer
Sentry software is very well-regarded among developers, with a perfect 5-star rating on Gartner Peer Insights, although it's based on a limited number of reviews (3) compared to other tools like Datadog. This suggests a high level of satisfaction among its users, but the small sample size should be considered when evaluating its overall reputation.
Session: e29d27a8-9ef6-4016-b68e-b23a72297fc8

[Similarity: 0.78] Task: hello!
Solution: **Evidence :**
The provided evidence is a friendly greeting response, which includes a statement to initiate a conversation. It acknowledges the user's greeting and asks about their day.

**Final Answer:**
Hello! It's great to meet you! How's your day going so far?
Session: d5b16953-f9fe-49a8-bc89-6d9ea515a846

[Similarity: 0.78] Task: hello!
Solution: **Evidence :**
The evidence provides a greeting response that acknowledges the user and offers assistance. It includes a friendly tone and an open-ended question to initiate a conversation.

**Final Answer:**
Hello! It's great to meet you. How can I assist you today?
Session: fcf13540-169d-4c79-b2a9-9ccee65a4512

[Similarity: 0.78] Task: hello!
Solution: To solve the task, let's first summarize the key information from the provided evidence.

**Summary of Evidence :**
Evidence  provides a friendly response to a greeting, which includes an expression of enthusiasm for meeting the user and an inquiry about the user's day.

**Final Answer:**
Given the task is to respond to the greeting "hello!", the most appropriate response based on Evidence  is:

Hello! It's great to meet you! How's your day going so far?
Session: 6bb763d7-735d-466a-abed-b61974d78016

[Similarity: 0.76] Task: what have we been chatting about recently, is there any theme to it?
Solution: **Evidence :**
- Recent memory indicates a discussion about John Lennon giving Eric Burdon the nickname "The Eggman" due to Burdon's habit of breaking raw eggs on girls during sexual encounters.

**Evidence :**
- Analysis of recent discussions reveals a recurring theme of rock and roll history and nicknames, particularly focusing on the nickname "The Eggman" and its origin.

**Final Answer:**
We have been chatting about rock and roll history, with a particular focus on nicknames and their origins. The most prominent example is the nickname "The Eggman," which John Lennon gave to Eric Burdon due to his controversial behavior. This theme has been a recurring part of our recent discussions.
Session: 0ddb3feb-deb1-47af-b2c2-5cbd9a50f908
```


### \#E5

```
The Principle of Least Surprise (POLA), also known as the Principle of Least Astonishment, is a fundamental design principle that aims to minimize surprises or confusion for users and programmers when interacting with a system or interface. This principle is closely related to other programming principles, such as KISS, YAGNI, DRY, SoC, and consistency.

**Definition and Purpose:**

The Principle of Least Surprise states that a system or interface should behave in a way that is most expected by its users, avoiding unexpected behavior and astonishing or surprising interactions. The purpose of this principle is to create systems and interfaces that are intuitive, easy to use, and minimize user frustration.

**Key Aspects:**

1. **Consistency:** A system should behave consistently and predictably, with consistent navigation, icon design, form behavior, error messages, and button behavior.
2. **Intuitive Design:** A system should be designed to be intuitive, with clear and concise labeling, logical sorting and filtering, and predictable functionality.
3. **Minimizing Surprises:** A system should minimize surprises and unexpected behavior, avoiding astonishing or surprising interactions.

**Examples:**

1. **Consistent Navigation:** A website's navigation menu should be consistent across all pages, with the same layout, typography, and functionality.
2. **Intuitive Icon Design:** Icons should be designed to be easily recognizable and intuitive, such as a trash can icon for deleting items.
3. **Predictable Form Behavior:** When filling out a form, users expect the "Submit" button to submit the form, not to clear the fields or take them to a different page.
4. **Standardized Error Messages:** Error messages should be clear, concise, and consistent in their formatting and language, helping users quickly understand what went wrong and how to fix it.
5. **Consistent Button Behavior:** Buttons should behave consistently throughout a system, with a "Cancel" button always canceling the current action, not confirming it.

**Benefits:**

1. **Improved User Experience:** By minimizing surprises, a system is more likely to be intuitive and easy to use, leading to a better user experience.
2. **Reduced Errors:** Surprises can lead to errors, so by minimizing surprises, a system is less likely to produce errors.
3. **Increased Maintainability:** A system that is designed with the POLA principle in mind is more likely to be maintainable, as it is easier to understand and modify.
4. **Better Scalability:** A system that is designed with the POLA principle in mind is more likely to be scalable, as it is easier to add new features without introducing surprises.

**Challenges and Limitations:**

1. **Subjective Nature:** The POLA principle is subjective, as what may be surprising to one user may not be surprising to another.
2. **Context-Dependent:** The POLA principle is context-dependent, as what may be surprising in one context may not be surprising in another.
3. **Trade-Offs:** The POLA principle may require trade-offs with other design principles, such as simplicity or performance.

In conclusion, the Principle of Least Surprise is a fundamental design principle that is closely related to other programming principles. By minimizing surprises and creating systems that are intuitive, consistent, and predictable, designers can improve the user experience, reduce errors, and increase maintainability and scalability. However, the POLA principle is subjective and context-dependent, and may require trade-offs with other design principles.
```


## Final Result

To solve the task, let's summarize the key information from each piece of evidence:

\- \*\*Evidence \#E1\*\*: Provides a definition of the Principle of Least Surprise \(POLA\), stating it's a design principle that aims to minimize surprises or confusion for users or programmers by having a system or interface behave in an expected manner\.

\- \*\*Evidence \#E2\*\*: Summarizes the principle, emphasizing its goal of minimizing surprises and provides a foundation for understanding its application and benefits in software development, though the details are truncated\.

\- \*\*Evidence \#E3\*\*: Discusses the relationship between POLA and other programming principles like KISS \(Keep it Simple, Stupid\) and YAGNI \(You Ain't Gonna Need It\), indicating that POLA is closely related to these principles, which all aim to simplify and clarify software design and development\.

\- \*\*Evidence \#E4\*\*: Provides a memory recall of discussions on programming principles, mentioning a similarity with a task about the Sentry software tool, but it does not directly contribute to the understanding of the Principle of Least Surprise\.

\- \*\*Evidence \#E5\*\*: Offers a detailed explanation of POLA, reiterating its fundamental role in design principles and its relationship with other programming principles, aiming to provide a comprehensive understanding, though the details are truncated\.

Based on the provided evidence, the key points about the Principle of Least Surprise in programming are:
\- It is a design principle\.
\- Its primary goal is to minimize surprises or confusion for users and programmers\.
\- It suggests that systems or interfaces should behave in a way that is most expected, to avoid astonishment or confusion\.
\- It is related to other principles such as KISS and YAGNI, which all aim to simplify software development and use\.

\*\*Final Answer\*\*: The Principle of Least Surprise \(POLA\) in programming is a design principle that aims to minimize surprises or confusion for users and programmers by ensuring that a system or interface behaves in the most expected and straightforward manner, closely aligning with the goals of simplicity and clarity found in other programming principles like KISS and YAGNI\.


## Token Usage

| Source | Tool | Prompt | Completion | Total |
|--------|------|---------|------------|--------|
| planner | - | 858 | 279 | 1137 |
| tool | LLM | 541 | 535 | 1076 |
| tool | LLM | 543 | 673 | 1216 |
| tool | LLM | 2473 | 707 | 3180 |
| solver | - | 815 | 421 | 1236 |
| **Total** | - | **5230** | **2615** | **7845** |
</document_content>
</document>
<document index="19">
<source>src/ReWOO/db/postgres_database.ts</source>
<document_content>
// ~/src/ReWOO/db/postgres_database.ts

import { Pool } from 'pg';

export class PostgresDatabase {
  public pool: Pool;

  constructor() {
    this.pool = new Pool({
      host: process.env.POSTGRES_HOST || 'localhost',
      database: process.env.POSTGRES_DB || 'rewoo',
      user: process.env.POSTGRES_USER || 'postgres',
      password: process.env.POSTGRES_PASSWORD || 'postgres',
      port: parseInt(process.env.POSTGRES_PORT || '5432'),
    });
  }

  async init(): Promise<void> {
    try {
      await this.pool.query(`CREATE EXTENSION IF NOT EXISTS vector`);
      await this.pool.query(`
        CREATE TABLE IF NOT EXISTS solutions (
          id TEXT PRIMARY KEY,
          session_id TEXT NOT NULL,
          task TEXT NOT NULL,
          solution TEXT NOT NULL,
          embedding VECTOR(1536),
          metadata JSONB,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
      `);
    } catch (error) {
      console.error('Failed to initialize database:', error);
      throw error;
    }
  }

  async cleanup(): Promise<void> {
    await this.pool.end();
  }
}

</document_content>
</document>
<document index="20">
<source>src/ReWOO/services/memory_service.ts</source>
<document_content>
// ~/src/ReWOO/services/memory_service.ts

import { v4 as uuid } from 'uuid';

import { PostgresDatabase } from '../db/postgres_database';

import { AiGenerate, type AiConfig } from '../ai';

export class MemoryService {
  private ai: AiGenerate;
  private db: PostgresDatabase;

  constructor(ai_config: AiConfig) {
    this.ai = new AiGenerate(ai_config);
    this.db = new PostgresDatabase();
    this.db.init().catch(console.error);
  }

  private clean_solution_text(text: string): string {
    return text.replace(/#E\d+|#[A-Za-z0-9_]+|\(#[A-Za-z0-9_]+\)/g, '');
  }

  async store_solution(
    session_id: string,
    task: string,
    solution: string,
    metadata: any = {}
  ): Promise<void> {
    try {
      const embedding = await this.ai.get_embedding(task);
      const cleaned_solution = this.clean_solution_text(solution);
      const formatted_embedding = `[${embedding.join(',')}]`;
      const solution_id = uuid();

      await this.db.pool.query(
        `INSERT INTO solutions(id, session_id, task, solution, embedding, metadata)
         VALUES($1, $2, $3, $4, $5, $6)`,
        [
          solution_id,
          session_id,
          task,
          cleaned_solution,
          formatted_embedding,
          JSON.stringify(metadata),
        ]
      );
    } catch (error) {
      console.error('Error storing solution:', error);
      throw error;
    }
  }

  async cleanup(): Promise<void> {
    await this.db.cleanup();
  }
}

</document_content>
</document>
</documents>
